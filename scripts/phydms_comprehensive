#!python

"""Comprehensive model comparison and selection-detection with ``phydms``.

Written by Jesse Bloom and Sarah Hilton."""


import sys
import os
import re
import time
import logging
import multiprocessing
import subprocess
import glob
#import signal
#import Bio.Alphabet.IUPAC
#import Bio.Phylo
import phydmslib
import phydmslib.file_io
import phydmslib.parsearguments
import pandas as pd

def RunCmds(cmds):
    """Runs the command line arguments in *cmds* using *subprocess*."""
    try:
        p = subprocess.Popen(cmds, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        pid = p.pid
        (stdout, stderr) = p.communicate()
    except:
        os.kill(pid, signal.SIGTERM)

def createModelComparisonFile(models, outprefix):
    """Creates a pandas dataframe for the parameter and log likelihood values"""
    temp = {"Model":[], "parameter":[], "value":[]}
    final = pd.DataFrame({"Model":[],"parameter":[], "value":[]})
    for modelName in models.keys():
        df = pd.read_csv(outprefix + modelName + "_modelparams.txt", sep = " = ", header = None)
        df.columns = ['parameter', 'value']
        df["Model"] = [modelName for x in range(len(df))]
        final = pd.concat([final,df])
        with open(outprefix + modelName + "_loglikelihood.txt") as f:
            lines = f.readlines()
            temp["Model"].append(modelName)
            temp["parameter"].append("LogLikelihood")
            temp["value"].append(lines[0].split(" = ")[-1])
        final = pd.concat([final, pd.DataFrame(temp)])
    final.to_csv("modelcomparison.csv")
    print(final)


def main():
    """Main body of script."""

    # Parse command line arguments
    parser = phydmslib.parsearguments.PhyDMSComprehensiveParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    #create output directory if needed
    outdir = os.path.dirname(args['outprefix'])
    if outdir:
        if not os.path.isdir(outdir):
            if os.path.isfile(outdir):
                os.remove(outdir)
            os.mkdir(outdir)

    #setup files
    # file names slightly different depending on whether outprefix is directory or file
    if args['outprefix'][-1] == '/':
        logfile = "{0}log.log".format(args['outprefix'])
    else:
        logfile = "{0}.log".format(args['outprefix'])
        args['outprefix'] = '{0}_'.format(args['outprefix'])
    modelcomparisonfile = '{0}modelcomparison.txt'.format(args['outprefix'])

    #Set up to log everything to logfile.
        # Set up to log everything to logfile.
    if os.path.isfile(logfile):
        os.remove(logfile)
    logging.shutdown()
    logging.captureWarnings(True)
    versionstring = phydmslib.file_io.Versions()
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s',
        level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)

    #print some basic information
    logger.info('Beginning execution of {0} in directory {1}\n'.format(prog, os.getcwd()))
    logger.info('Progress is being logged to {0}\n'.format(logfile))
    logger.info('{0}\n'.format(versionstring))
    #need to format the following:
    logger.info('Parsed the following command-line arguments:\n {0}'.format(args))

    #setup models
    filesuffixlist = ['.log', '_tree.newick', '_loglikelihood.txt', '_modelparams.txt']
    filesuffixes = {} # keyed by model, values are list of suffixes
    models = {}

    models = {'YNGKP_M0':('YNGKP_M0', 9)}
    filesuffixes['YNGKP_M0'] = filesuffixlist
    for prefsfile in args['prefsfiles']:
        if re.search('\s', prefsfile):
            raise ValueError("There is a space in the preferences file name: %s" % prefsfile)
        prefsfilebase = os.path.splitext(os.path.basename(prefsfile))[0]
        modelname = 'ExpCM_{0}'.format(prefsfilebase)
        assert modelname not in filesuffixes, "Duplicate preferences file base name %s for %s; make names unique even after removing directory and extension" % (modelname, prefsfile)
        filesuffixes[modelname] = filesuffixlist
        models[modelname] = ('ExpCM_{0}'.format(prefsfile),0)





    #read or build a tree
    if args["tree"]:
      logger.info("Reading tree from {0}".format(args['tree']))
    else:
      logger.info("You did not specify a tree. Inferring tree using RAxML")
      try:
          raxmlversion = subprocess.check_output([args['raxml'], '-v'], stderr=subprocess.STDOUT).strip()
          print("Inferring tree with RAxML using {0} {1}".format(args['raxml'], raxmlversion))

          #remove pre-existing RAxML files
          raxmlOutputName = os.path.splitext(os.path.basename(args["alignment"]))[0]
          raxmlOutputFiles = [n for n in glob.glob("RAxML_*{0}".format(raxmlOutputName)) if os.path.isfile(n)]
          raxmlOutputFiles = []
          for raxmlFile in glob.glob("RAxML_*{0}".format(raxmlOutputName)):
              if os.path.isfile(raxmlFile):
                  raxmlOutputFiles.append(raxmlFile)
                  os.remove(raxmlFile)
          if len(raxmlOutputFiles) > 0:
              logger.info("Removed the following `RAxML` files: ")
              logger.info(raxmlOutputFiles) #still need to format

        # run RAxmL
          raxmlCMD = [args['raxml'], '-s', args['alignment'], '-n', raxmlOutputName,
                '-m', 'GTRCAT', '-p1', '-T', '2']
          subprocess.check_call(raxmlCMD)

        # move RAxML tree to output directory and remove all other files
          for  raxmlFile in glob.glob("RAxML_*{0}".format(raxmlOutputName)):
              if "bestTree" in raxmlFile:
                  os.rename(raxmlFile, args["outprefix"] + raxmlFile)
                  args["tree"] = args["outprefix"] + raxmlFile
                  logger.info("RAxML inferred tree, {0}, is in {1}.".format(raxmlFile, args["outprefix"]))
              else:
                  os.remove(raxmlFile)
      except OSError:
          raise ValueError("The raxml command of {0} is not valid. Is raxml installed at this path?".format(args['raxml']))



    #check alignment
    logger.info('Checking that the alignment {0} is valid...'.format(args['alignment']))
    alignment = phydmslib.file_io.ReadCodonAlignment(args['alignment'], checknewickvalid=True)
    logger.info('Valid alignment specifying {0} sequences of length {1}.\n'.format(len(alignment), len(alignment[0][1])))

    # get number of available CPUs and assign to each model
    if args['ncpus'] == -1:
        try:
            args['ncpus'] = multiprocessing.cpu_count()
        except:
            raise RuntimeError("Encountered a problem trying to dynamically determine the number of available CPUs. Please manually specify the number of desired CPUs with '--ncpus' and try again.")
            logger.info('Will use all %d available CPUs.\n' % args['ncpus'])
    assert args['ncpus'] >= 1, "Failed to specify valid number of CPUs"
    # YNGKP models get one CPU, ExpCM get more than one if excess over number of models
    expcm_modelnames = [modelname for modelname in models.keys() if 'ExpCM' in modelname]
    yngkp_modelnames = [modelname for modelname in models.keys() if 'YNGKP' in modelname]
    assert len(models.keys()) == len(expcm_modelnames) + len(yngkp_modelnames), "not ExpCM or YNGKP:\n%s" % str(models.keys())
    ncpus_per_model = dict([(modelname, 1) for modelname in yngkp_modelnames])
    ncpus_per_model['YNGKP_M0'] = args['ncpus'] # YNGKP_M0 runs first, so give it all CPUs
    nperexpcm = max(1, (args['ncpus'] - len(yngkp_modelnames) + 1) // len(expcm_modelnames)) # add one in numerator since YNGKP_M0 fit first
    for modelname in expcm_modelnames:
        ncpus_per_model[modelname] = nperexpcm
    for modelname in models.keys():
        mtup = models[modelname]
        assert len(mtup) == 2 # should be 3-tuple
        models[modelname] = (mtup[0], ['--ncpus', str(ncpus_per_model[modelname])], mtup[1]) # add to additionalcmds, second tuple element


    pool = {} # holds process for model name
    started = {} # holds whether process started for model name
    completed = {} # holds whether process completed for model name
    outprefixes = {} # holds outprefix for model name

    # rest of execution in try / finally
    try:

        # remove existing output files
        outfiles = []
        removed = []
        for modelname in models.keys():
            for suffix in filesuffixes[modelname]:
                fname = "%s%s%s" % (args['outprefix'], modelname, suffix)
                outfiles.append(fname)
        for fname in outfiles:
            if os.path.isfile(fname):
                os.remove(fname)
                removed.append(fname)
        if removed:
            logger.info('Removed the following existing files that have names that match the names of output files that will be created: {0}\n'.format(', '.join(removed)))

        #first estimate tree with phydms using YNGKP_M0 model
        modelname = 'YNGKP_M0'
        (model, additionalcmds, nempirical) = models[modelname]
        outprefix = "%s%s" % (args['outprefix'], modelname)
        treefile = '%s_tree.newick' % outprefix

        # set up the commands
        cmds = ['phydms', args['alignment'], args['tree'], model, outprefix] + additionalcmds
        logger.info('Optimizing tree in {0} using the {1} model. The command is: {2}'.format(args['tree'], model, ' '.join(cmds)))

        p = multiprocessing.Process(target=RunCmds, args=(cmds,))
        pool[modelname] = p
        completed[modelname] = False
        outprefixes[modelname] = outprefix
        started[modelname] = True
        p.start()
        p.join()
        completed[modelname] = True
        for fname in [outprefix + suffix for suffix in filesuffixes[modelname]]:
            if not os.path.isfile(fname):
                raise RuntimeError("phydms failed to created expected output file %s." % fname)
            logger.info("Found expected output file %s" % fname)
        logger.info('Analysis successful for %s\n' % model)
        assert os.path.isfile(treefile)

    #now run the other models
        for modelname in [xmodel for xmodel in models.keys() if 'YNGKP_M0' != xmodel]:
            (model, additionalcmds, nempirical) = models[modelname]
            outprefix = "%s%s" % (args['outprefix'], modelname)
            cmds = ['phydms', args['alignment'], treefile, model, outprefix] + additionalcmds
            logger.info('Starting analysis to optimize tree in %s using model %s. The command is: %s\n' % (treefile, modelname, ' '.join(cmds)))
            pool[modelname] = multiprocessing.Process(target=RunCmds, args=(cmds,))
            outprefixes[modelname] = outprefix
            completed[modelname] = False
            started[modelname] = False
        while not all(completed.values()):
            nrunning = list(started.values()).count(True) - list(completed.values()).count(True)
            if nrunning < args['ncpus']:
                for (modelname, p) in pool.items():
                    if not started[modelname]:
                        p.start()
                        started[modelname] = True
                        break
            for (modelname, p) in pool.items():
                if started[modelname] and (not completed[modelname]) and (not p.is_alive()): # process just completed
                    completed[modelname] = True
                    logger.info('Analysis completed for %s' % modelname)
                    for fname in [outprefixes[modelname] + suffix for suffix in filesuffixes[modelname]]:
                        if not os.path.isfile(fname):
                            raise RuntimeError("phydms failed to created expected output file %s." % fname)
                        logger.info("Found expected output file %s" % fname)
                    logger.info('Analysis successful for %s\n' % modelname)
            time.sleep(1)

    #make sure all expected output files are there
        for fname in outfiles:
            if not os.path.isfile(fname):
                raise RuntimeError("Cannot find expected output file %s" % fname)
        createModelComparisonFile(models, args["outprefix"])


    except:
        logger.exception('Terminating %s at %s with ERROR' % (prog, time.asctime()))
    else:
        logger.info('Successful completion of %s' % prog)
    finally:
        logging.shutdown()
        for p in pool.values():
            if p.is_alive():
                p.terminate()


if __name__ == '__main__':
    main() # run the script
