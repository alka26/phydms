#!python

"""Test different diversifying pressure models with ``phydms``.

Written by Jesse Boom and Sarah Hilton.
"""


import sys
import os
import re
import time
import logging
import multiprocessing
import subprocess
import glob
import phydmslib
import phydmslib.file_io
import phydmslib.parsearguments
import pandas as pd

def randomizeDivpressure(divpressureFile,numberRandomizations,outprefix):
    """Randomizes the diversifying pressures value the number of times specified by the user
       Each randomization is written to a file in the directory 'randomFiles'
       Returns a list of the new file names
    """
    outdir = os.path.dirname(outprefix+"randomizedFiles/")
    if outdir:
        if not os.path.isdir(outdir):
            if os.path.isfile(outdir):
                os.remove(outdir)
            os.mkdir(outdir)
    fileList = []
    with open(divpressureFile) as f:
        lines = [line.split() for line in f.readlines() if not line.isspace() and line[0] != '#']
    assert all([len(line) == 2 for line in lines])
    sites = [tup[0] for tup in lines]
    divpressures = [tup[1] for tup in lines]
    for seed in range(int(numberRandomizations)):
        random.seed(seed)
        random.shuffle(divpressures)
        randomDivpressureFile = outdir+'/%s_random_%s.txt' %((divpressureFile.split(".")[-2]), str(seed))
        with open(randomDivpressureFile, 'w') as f:
            f.write('\n'.join('{0} {1}'.format(site, dp) for (site, dp) in zip(sites, divpressures)))
        fileList.append(randomDivpressureFile)
    return fileList

def tabulateResults(fileList, modelComparisonName):
    """
    Creates a csv summarizes the results from each model
    """
    finalOutput = []
    finalOutput.append("Name,DiversifyingPressure,LogLikelihood,Omega,Omega2,kappa,betta, phiA, phiC, phiG\n")
    for file in fileList:
        name = os.path.basename(file)
        type = name.split("_")[-1]
        with open(file + "_modelparams.txt") as f:
            modelparamstext = f.read()
            kappa = re.search('123_K80.kappa = (\d+\.\d+)', modelparamstext).group(1)
            omega = float(re.search('omega = (\d+\.\d+)', modelparamstext).group(1))
            if re.search('omega2 = (\d+\.\d+)', modelparamstext):
                omega2 = float(re.search('omega2 = (\d+\.\d+)', modelparamstext).group(1))
            elif re.search('omega2 = (-\d+\.\d+)', modelparamstext):
                omega2 = float(re.search('omega2 = (-\d+\.\d+)', modelparamstext).group(1))
            else:
                omega2 = "N/A"
            beta = float(re.search('stringencyparameter = (\d+\.\d+)', modelparamstext).group(1))
            theta = float(re.search('123_Full.theta = (\d+\.\d+)', modelparamstext).group(1))
            theta1 = float(re.search('123_Full.theta1 = (\d+\.\d+)', modelparamstext).group(1))
            theta2 = float(re.search('123_Full.theta2 = (\d+\.\d+)', modelparamstext).group(1))
        phiA = theta1 * (1.0 - theta)
        phiC = (1.0 - theta2) * theta
        phiG = theta * theta2
        with open(file + "_loglikelihood.txt") as f:
            loglikelihoodtext = f.read()
            LL = float(re.search('log likelihood = (-\d+\.\d+)', loglikelihoodtext).group(1))
        if type =="noDiversifyingpressure":
            type = "none"
        elif type.startswith("random"):
            type = "random"
        else:
            type = "true"
        newLine= ",".join([str(x) for x in [file,type,LL, kappa, omega, omega2, beta, phiA, phiC, phiG]])+"\n"
        finalOutput.append(newLine)
        with open(modelComparisonName,'wb') as f:
            for item in finalOutput:
                f.write(item)

def RunCmds(cmds):
    """Runs the command line arguments in *cmds* using *subprocess*."""
    try:
        p = subprocess.Popen(cmds, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        pid = p.pid
        (stdout, stderr) = p.communicate()
    except:
        os.kill(pid, signal.SIGTERM)

def main():
    """Main body of script."""

    # Parse command line arguments
    parser = phydmslib.parsearguments.PhyDMSTestdivpressureParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    #create output directory if needed
    outdir = os.path.dirname(args['outprefix'])
    if outdir:
        if not os.path.isdir(outdir):
            if os.path.isfile(outdir):
                os.remove(outdir)
            os.mkdir(outdir)

    #setup files
    #file names depend on whether outprefix is directory or file
    if args['outprefix'][-1] == '/':
        logfile = "{0}log.log".format(args['outprefix'])
    else:
        logfile = "{0}.log".format(args['outprefix'])
        args['outprefix'] = '{0}_'.format(args['outprefix'])
    modelcomparisonfile = '{0}modelcomparison.txt'.format(args['outprefix'])

    #Set up to log everything to logfile.
        # Set up to log everything to logfile.
    if os.path.isfile(logfile):
        os.remove(logfile)
    logging.shutdown()
    logging.captureWarnings(True)
    versionstring = phydmslib.file_io.Versions()
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s',
        level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)

    #print some basic information
    logger.info('Beginning execution of {0} in directory {1}\n'
            .format(prog, os.getcwd()))
    logger.info('Progress is being logged to {0}\n'.format(logfile))
    logger.info('{0}\n'.format(versionstring))
    logger.info('Parsed the following command-line arguments:\n{0}\n'
            .format('\n'.join(['\t{0} = {1}'.format(key, args[key])
            for key in args.keys()])))

    #Set up to log everything to logfile.
    if os.path.isfile(logfile):
        os.remove(logfile)
    logging.shutdown()
    versionstring = phydmslib.file_io.Versions()
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s',
            level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)

    #print some basic information
    logger.info('Beginning execution of {0} in directory {1}\n'
            .format(prog, os.getcwd()))
    logger.info('Progress is being logged to {0}\n'.format(logfile))
    logger.info('{0}\n'.format(versionstring))
    logger.info('Parsed the following command-line arguments:\n{0}\n'
            .format('\n'.join(['\t{0} = {1}'.format(key, args[key])
            for key in args.keys()])))

    #setup models
    filesuffixlist = ['.log', '_tree.newick', '_loglikelihood.txt',
            '_modelparams.txt']
    filesuffixes = {} # keyed by model, values are list of suffixes
    models = {}

    #set up the ExpCM
    expcmadditionalcmds = []
    nempiricalExpCM = 3
    if re.search('\s', args['prefsfile']):
        raise ValueError("There is a space in the preferences file name:\
                {0}".format(args['prefsfile']))
    prefsfilebase = os.path.splitext(os.path.basename(args['prefsfile']))[0]
    modelname = 'ExpCM_{0}'.format(prefsfilebase)
    assert modelname not in filesuffixes, "Duplicate preferences file"\
            " base name {0} for {1}; make names unique even after "\
            "removing directory and extension".format(modelname, args['prefsfile'])
    filesuffixes[modelname] = filesuffixlist
    models[modelname] = ('ExpCM_{0}'.format(args['prefsfile']),
            expcmadditionalcmds, nempiricalExpCM)

    # check alignment
    logger.info('Checking that the alignment {0} is valid...'
            .format(args['alignment']))
    alignment = phydmslib.file_io.ReadCodonAlignment(args['alignment'],
            checknewickvalid=True) #checks that the identifiers are unique
    assert len(set([align[1] for align in alignment])) == len([align[1]
            for align in alignment]), "Remove duplicate sequences from {0}."\
                    .format(args["alignment"])
    logger.info('Valid alignment specifying {0} sequences of length {1}.\n'
            .format(len(alignment), len(alignment[0][1])))


    #read or build a tree
    if args["tree"]:
      logger.info("Reading tree from {0}".format(args['tree']))
    else:
        logger.info("Tree not specified.")
        try:
            raxmlversion = subprocess.check_output([args['raxml'], '-v'],
                    stderr=subprocess.STDOUT).strip()
            logger.info("Inferring tree with RAxML using command {0}"
                    .format(args['raxml']))

            #remove pre-existing RAxML files
            raxmlOutputName = os.path.splitext(os.path.basename(
                    args["alignment"]))[0]
            raxmlOutputFiles = [n for n in glob.glob("RAxML_*{0}"
                    .format(raxmlOutputName)) if os.path.isfile(n)]
            raxmlOutputFiles = []
            for raxmlFile in glob.glob("RAxML_*{0}".format(raxmlOutputName)):
                if os.path.isfile(raxmlFile):
                    raxmlOutputFiles.append(raxmlFile)
                    os.remove(raxmlFile)
            if len(raxmlOutputFiles) > 0:
                logger.info('Removed the following RAxML files:\n{0}\n'
                    .format('\n'.join(['\t{0}'.format(fname) for
                    fname in raxmlOutputFiles])))

         # run RAxmL
            raxmlCMD = [args['raxml'], '-s', args['alignment'], '-n',
                    raxmlOutputName, '-m', 'GTRCAT', '-p1', '-T', '2']
            subprocess.check_call(raxmlCMD)

         # move RAxML tree to output directory and remove all other files
            for  raxmlFile in glob.glob("RAxML_*{0}".format(raxmlOutputName)):
                if "bestTree" in raxmlFile:
                    os.rename(raxmlFile, args["outprefix"] + raxmlFile)
                    args["tree"] = args["outprefix"] + raxmlFile
                    logger.info("RAxML inferred tree, {0}, is in {1}."
                            .format(raxmlFile, args["outprefix"]))
                else:
                    os.remove(raxmlFile)
        except OSError:
            raise ValueError("The raxml command of {0} is not valid."
                    " Is raxml installed at this path?".format(args['raxml']))

    #setting up cpus
    if args['ncpus'] == -1:
        try:
            args['ncpus'] = multiprocessing.cpu_count()
        except:
            raise RuntimeError("Encountered a problem trying to dynamically determine the number of available CPUs. Please manually specify the number of desired CPUs with '--ncpus' and try again.")
        logger.info('Will use all %d available CPUs.\n' % args['ncpus'])
    assert args['ncpus'] >= 1, "Failed to specify valid number of CPUs"

    pool = {} # holds process for model name
    started = {} # holds whether process started for model name
    completed = {} # holds whether process completed for model name
    outprefixes = {} # holds outprefix for model name

    # rest of execution in try / finally
    try:

        # remove existing output files
        outfiles = []
        removed = []
        for modelname in models.keys():
            for suffix in filesuffixes[modelname]:
                fname = "{0}{1}{2}".format(args['outprefix'], modelname, suffix)
                outfiles.append(fname)
        for fname in outfiles:
            if os.path.isfile(fname):
                os.remove(fname)
                removed.append(fname)
        if removed:
            logger.info('Removed the following existing files that have names'
                    " that match the names of output files that will be "
                    'created: {0}\n'.format(', '.join(removed)))

    #now run the other models
        for modelname in list(models.keys()):
            (model, additionalcmds, nempirical) = models[modelname]
            outprefix = "{0}{1}".format(args['outprefix'], modelname)
            cmds = ['phydms', args['alignment'], args["tree"], model,
                    outprefix] + additionalcmds
            logger.info('Starting analysis to optimize tree in {0} using model '
                    '{1}. The command is: {2}\n'.format( args["tree"],
                    modelname, ' '.join(cmds)))
            pool[modelname] = multiprocessing.Process(target=RunCmds\
                    , args=(cmds,))
            outprefixes[modelname] = outprefix
            completed[modelname] = False
            started[modelname] = False
        while not all(completed.values()):
            nrunning = list(started.values()).count(True) - \
                    list(completed.values()).count(True)
            if nrunning < args['ncpus']:
                for (modelname, p) in pool.items():
                    if not started[modelname]:
                        p.start()
                        started[modelname] = True
                        break
            for (modelname, p) in pool.items():
                if started[modelname] and (not completed[modelname]) and \
                        (not p.is_alive()): # process just completed
                    completed[modelname] = True
                    logger.info('Analysis completed for {0}'.format(modelname))
                    for fname in [outprefixes[modelname] + suffix for suffix
                            in filesuffixes[modelname]]:
                        if not os.path.isfile(fname):
                            raise RuntimeError("phydms failed to created"
                                    " expected output file {0}.".format(fname))
                        logger.info("Found expected output file {0}"\
                                .format(fname))
                    logger.info('Analysis successful for {0}\n'\
                            .format(modelname))
            time.sleep(1)

    #make sure all expected output files are there
        for fname in outfiles:
            if not os.path.isfile(fname):
                raise RuntimeError("Cannot find expected output file {0}"
                        .format(fname))


    except:
        logger.exception('Terminating {0} at {1} with ERROR'
                .format(prog, time.asctime()))
    else:
        logger.info('Successful completion of {0}'.format(prog))
    finally:
        logging.shutdown()
        for p in pool.values():
            if p.is_alive():
                p.terminate()


if __name__ == '__main__':
    main() # run the script
