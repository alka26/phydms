#!python

"""Plots selection inferred for an ExpCM with ``phydms``.

Written by Jesse Bloom."""


import sys
import os
import re
import phydmslib.file_io
import phydmslib.parsearguments


def main():
    """Main body of script."""

    # Parse command line arguments
    parser = phydmslib.parsearguments.PhyDMSPlotSelectionParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    # print some basic information
    print('Beginning execution of %s in directory %s at time %s\n' % (prog, os.getcwd(), time.asctime()))
    print("%s\n" % versionstring)
    logger.info('Parsed the following command-line arguments:\n%s\n' % '\n'.join(['\t%s = %s' % tup for tup in args.iteritems()]))

    # get number of available CPUs and assign to each model
    if args['ncpus'] == -1:
        try:
            args['ncpus'] = multiprocessing.cpu_count()
        except:
            raise RuntimeError("Encountered a problem trying to dynamically determine the number of available CPUs. Please manually specify the number of desired CPUs with '--ncpus' and try again.")
        logger.info('Will use all %d available CPUs.\n' % args['ncpus'])
    assert args['ncpus'] >= 1, "Failed to specify valid number of CPUs"
    # YNGKP models get one CPU, ExpCM get more than one if excess over number of models
    expcm_modelnames = [modelname for modelname in models.keys() if 'ExpCM' in modelname]
    yngkp_modelnames = [modelname for modelname in models.keys() if 'YNGKP' in modelname]
    assert len(models.keys()) == len(expcm_modelnames) + len(yngkp_modelnames), "not ExpCM or YNGKP:\n%s" % str(models.keys())
    ncpus_per_model = dict([(modelname, 1) for modelname in yngkp_modelnames])
    nperexpcm = max(1, (args['ncpus'] - len(yngkp_modelnames) + 1) // len(expcm_modelnames)) # add one in numerator since YNGKP_M0 fit first
    for modelname in expcm_modelnames:
        ncpus_per_model[modelname] = nperexpcm
    for modelname in models.keys():
        mtup = models[modelname]
        assert len(mtup) == 3 # should be 3-tuple
        models[modelname] = (mtup[0], mtup[1] + ['--ncpus', str(ncpus_per_model[modelname])], mtup[2]) # add to additionalcmds, second tuple element

    pool = {} # holds process for model name
    started = {} # holds whether process started for model name
    completed = {} # holds whether process completed for model name
    outprefixes = {} # holds outprefix for model name

    # rest of execution in try / finally
    try:

        # remove existing output files
        outfiles = []
        removed = []
        for modelname in models.keys():
            for suffix in filesuffixes[modelname]:
                fname = "%s%s%s" % (args['outprefix'], modelname, suffix)
                outfiles.append(fname)
        if os.path.isfile(modelcomparisonfile):
            os.remove(modelcomparisonfile)
        for fname in outfiles:
            if os.path.isfile(fname) and not args['use_existing']:
                os.remove(fname)
                removed.append(fname)
        if removed:
            logger.info('Removed the following existing files that have names that match the names of output files that will be created: %s\n' % ', '.join(removed))

        # first estimate tree with phydms using YNGKP_M0 model
        modelname = 'YNGKP_M0'
        (model, additionalcmds, nempirical) = models[modelname]
        outprefix = "%s%s" % (args['outprefix'], modelname)
        treefile = '%s_tree.newick' % outprefix
        if args['use_existing'] and all([os.path.isfile(outprefix + suffix) for suffix in filesuffixes[modelname]]):
            logger.info('Using existing output for %s\n' % model)
        else:
            if args['treetopology']:
                cmds = ['phydms', args['alignment'], args['treetopology'], model, outprefix] + additionalcmds
                logger.info('Optimizing tree in %s using the %s model. The command is: %s' % (model, args['treetopology'], ' '.join(cmds)))
            else:
                cmds = ['phydms', args['alignment'], 'nj', model, outprefix, '--infertopology'] + additionalcmds
                logger.info('Inferring topology using the %s model starting from a simple neighbor joining tree. The command is: %s' % (model, ' '.join(cmds)))
            p = multiprocessing.Process(target=RunCmds, args=(cmds,))
            pool[modelname] = p
            completed[modelname] = False
            outprefixes[modelname] = outprefix
            started[modelname] = True
            p.start()
            p.join()
            completed[modelname] = True
            for fname in [outprefix + suffix for suffix in filesuffixes[modelname]]:
                if not os.path.isfile(fname):
                    raise RuntimeError("phydms failed to created expected output file %s." % fname)
                logger.info("Found expected output file %s" % fname)
            logger.info('Analysis successful for %s\n' % model)
        assert os.path.isfile(treefile)

        # now run the other models
        for modelname in [xmodel for xmodel in models.keys() if 'YNGKP_M0' != xmodel]:
            (model, additionalcmds, nempirical) = models[modelname]
            outprefix = "%s%s" % (args['outprefix'], modelname)
            if args['use_existing'] and all([os.path.isfile(outprefix + suffix) for suffix in filesuffixes[modelname]]):
                logger.info('Using existing output for %s\n' % modelname)
            else:
                cmds = ['phydms', args['alignment'], treefile, model, outprefix] + additionalcmds
                logger.info('Starting analysis to optimize tree in %s using model %s. The command is: %s\n' % (treefile, modelname, ' '.join(cmds)))
                pool[modelname] = multiprocessing.Process(target=RunCmds, args=(cmds,))
                outprefixes[modelname] = outprefix
                completed[modelname] = False
                started[modelname] = False
        while not all(completed.values()):
            nrunning = started.values().count(True) - completed.values().count(True)
            if nrunning < args['ncpus']:
                for (modelname, p) in pool.items():
                    if not started[modelname]:
                        p.start()
                        started[modelname] = True
                        break
            for (modelname, p) in pool.items():
                if started[modelname] and (not completed[modelname]) and (not p.is_alive()): # process just completed
                    completed[modelname] = True
                    logger.info('Analysis completed for %s' % modelname)
                    for fname in [outprefixes[modelname] + suffix for suffix in filesuffixes[modelname]]:
                        if not os.path.isfile(fname):
                            raise RuntimeError("phydms failed to created expected output file %s." % fname)
                        logger.info("Found expected output file %s" % fname)
                    logger.info('Analysis successful for %s\n' % modelname)
            time.sleep(1)

        # make sure all expected output files are there
        for fname in outfiles:
            if not os.path.isfile(fname):
                raise RuntimeError("Cannot find expected output file %s" % fname)

        # tabulate model comparison
        logger.info("Tabulating model comparisons and writing to %s" % modelcomparisonfile)
        TabulateModelComparisons(modelcomparisonfile, models, args['outprefix'], '_loglikelihood.txt', '_modelparams.txt')
        with open(modelcomparisonfile) as f:
            modelcomparisontext = f.read()
        logger.info("Here are the results of the model comparison:\n\t%s" % modelcomparisontext.replace('\n', '\n\t'))

    except:
        logger.exception('Terminating %s at %s with ERROR' % (prog, time.asctime()))
    else:
        logger.info('Successful completion of %s' % prog)
    finally:
        logging.shutdown()
        for p in pool.values():
            if p.is_alive():
                p.terminate()


if __name__ == '__main__':
    main() # run the script
