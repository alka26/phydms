#!python

"""Phylogenetic inference using deep mutational scanning data.

Written by Jesse Bloom."""


import sys
import os
import re
import logging
import random
import time
import math
import multiprocessing
import scipy
import Bio.Phylo
import phydmslib
import phydmslib.constants
import phydmslib.file_io
import phydmslib.parsearguments
import phydmslib.models
import phydmslib.treelikelihood


def main():
    """Main body of script."""

    # Parse command line arguments
    parser = phydmslib.parsearguments.PhyDMSParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    # create output directory if needed
    outdir = os.path.dirname(args['outprefix'])
    if outdir:
        if not os.path.isdir(outdir):
            if os.path.isfile(outdir):
                os.remove(outdir)
            os.mkdir(outdir)

    # output files, remove if they already exist
    modelparamsfile = '%s_modelparams.txt' % args['outprefix']
    loglikelihoodfile = '%s_loglikelihood.txt' % args['outprefix']
    treefile = "%s_tree.newick" % args['outprefix']
    omegafile = '%s_omegabysite.txt' % args['outprefix']
    logfile = "%s.log" % args['outprefix']
    to_remove = [modelparamsfile, loglikelihoodfile, treefile, omegafile, logfile]
    for f in to_remove:
        if os.path.isfile(f):
            os.remove(f)

    # Set up to log everything to logfile.
    logging.shutdown()
    logging.captureWarnings(True)
    versionstring = phydmslib.file_io.Versions()
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s',
            level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)

    # begin execution
    try:
        # print some basic information
        logger.info('Beginning execution of {0} in directory {1}\n'.format(
                prog, os.getcwd()))
        logger.info('Progress is being logged to {0}\n'.format(logfile))
        logger.info("{0}\n".format(versionstring))
        logger.info('Parsed the following arguments:\n{0}\n'.format(
                '\n'.join(['\t{0} = {1}'.format(*tup) for tup in args.items()])))
        logger.info('Random number seed: {0}\n'.format(args['seed']))
        random.seed(args['seed'])

        # read alignment
        logger.info('Reading alignment from {0}'.format(args['alignment']))
        alignment = phydmslib.file_io.ReadCodonAlignment(args['alignment'],
                checknewickvalid=True)
        logger.info(('Read {0} aligned sequences from {1}, each consisting '
                'of {2} codons.\n').format(len(alignment), args['alignment'],
                len(alignment[0][1]) // 3))
        seqnames = set([head for (head, seq) in alignment])

        # process the substitution model
        yngkp_match = re.compile('^YNGKP_M(?P<modelvariant>\d+)$')
        if isinstance(args['model'], str) and yngkp_match.search(args['model']):
            for argname in ['randprefs', 'avgprefs', 'divpressure']:
                assert not args[argname], "'--%s' incompatible with YNKGP".format(
                            argname)
            modelvariant = yngkp_match.search(args['model']).group('modelvariant')
            logger.info(('The codon substitution model with be the M{0} version '
                    'of YNGKP (Yang, Nielsen, Goldman, and Pederson. Genetics. '
                    '155:431-449).').format(modelvariant))
            e_pw = scipy.ones((3,phydmslib.constants.N_NT), dtype='float')
            for p in range(3):
                for (w, nt) in phydmslib.constants.INDEX_TO_NT.items():
                    e_pw[p][w] = sum([list(seq)[p::3].count(nt) for (head, seq) in alignment])
            assert len(set(e_pw.sum(axis = 1))) == 1, "At least one codon position has a different number of nucleotides"
            assert scipy.any(e_pw.sum(axis= 0) != 0), "At least one nucleotide does not have any counts"
            e_pw = e_pw / e_pw.sum(axis = 1)[0]
            freeparams = ["omega", "kappa"]
            nsites = int(len(alignment[0][1])/3)
            model = phydmslib.models.YNGKP_M0(e_pw, nsites, freeparams=freeparams)
        elif (isinstance(args['model'], tuple) and len(args['model']) == 2 and
                args['model'][0] == 'ExpCM'):
            prefsfile = args['model'][1]
            logger.info(('The model will be an ExpCM informed by site-specific '
                    'amino-acid preferences in {0}').format(prefsfile))
            for (argname, desc) in [('avgprefs', 'averaged'),
                    ('randprefs', 'randomized')]:
                if args[argname]:
                    logger.info('Preferences will be {0} across sites.'.format(desc))
            prefs = phydmslib.file_io.readPrefs(prefsfile, minpref=args['minpref'],
                    avgprefs=args['avgprefs'], randprefs=args['randprefs'],
                    seed=args['seed'])
            sites = sorted(prefs.keys())
            prefslist = [prefs[r] for r in sites] # convert prefs from dict to list
            assert len(prefs) == len(alignment[0][1]) // 3, ("The number of "
                    "preferences in {0} does not match the number of codon "
                    "sites in the alignment").format(prefsfile)
            logger.info(('Successfully read site-specific amino-acid preferences '
                    'for all {0} sites.\n').format(len(prefs)))
            freeparams = ['kappa', 'omega', 'beta']
            if args['brlen'] == 'scale':
                logger.info("Scaling branch lengths by adding 'mu' parameter "
                        "to model.\n")
                freeparams.append('mu')
            if args['fitphi']:
                assert not args['divpressure'], (
                        "Can't use --divpressure and --fitphi")
                freeparams.append('eta')
                logger.info('Nucleotide frequency parameters phi will '
                        'be optimized by maximum likelihood.')
                model = phydmslib.models.ExpCM(prefslist, freeparams=freeparams)
            else:
                g = scipy.ndarray(phydmslib.constants.N_NT, dtype='float')
                for (w, nt) in phydmslib.constants.INDEX_TO_NT.items():
                    g[w] = sum([seq.count(nt) for (head, seq) in alignment])
                assert len(alignment) * len(prefs) * 3 == (g.sum() +
                        sum([seq.count('-') for (head, seq) in alignment])), (
                        "Alignment contains invalid nucleotide characters")
                g /= g.sum()
                logger.info('Nucleotide frequency parameters phi will be '
                        'set so stationary state matches alignment '
                        'nucleotide frequencies of {0}'.format(
                        ', '.join(['{0} = {1:.3f}'.format(nt, g[w]) for
                        (w, nt) in phydmslib.constants.INDEX_TO_NT.items()])))
                if not args['divpressure']:
                    model = phydmslib.models.ExpCM_empirical_phi(prefslist, g,
                        freeparams=freeparams)
                else:
                    for otherarg in ['omegabysite']:
                        if otherarg in args and args[otherarg]:
                            raise ValueError("Can't use --divpressure and "
                                    "--{0}".format(otherarg))
                    freeparams.append('omega2')
                    divpressure = phydmslib.file_io.readDivPressure(
                            args['divpressure'])
                    assert set(prefs.keys()) == set(divpressure.keys()), (
                            "The sites in {0} are different from {1}.".format(
                            args['divpressure'], prefsfile))
                    logger.info(('Read diversifying pressure from {0} '
                            'for all sites.').format(args['divpressure']))
                    divPressureSites = list(divpressure.keys())
                    divpressure = scipy.array([divpressure[x] for x in
                            sorted(divPressureSites)])
                    model = phydmslib.models.ExpCM_empirical_phi_divpressure(
                            prefslist, g, divpressure, freeparams=freeparams)
        else:
            raise ValueError("Invalid model of %s" % args['model'])

        # read tree
        logger.info("Reading tree from %s" % args['tree'])
        tree = Bio.Phylo.read(args['tree'], 'newick')
        tipnames = set([clade.name for clade in tree.get_terminals()])
        assert len(tipnames) == tree.count_terminals(), "non-unique tip names?"
        assert tipnames == seqnames, ("Names in alignment do not match those in "
                "tree.\nSequences in alignment but NOT in tree:\n\t{0}\n"
                "Sequences in tree but NOT in alignment:\n\t{1}".format(
                '\n\t'.join(seqnames - tipnames), '\n\t'.join(tipnames - seqnames)))
        logger.info('Tree has {0} tips.'.format(len(tipnames)))
        tree.root_at_midpoint()
        assert tree.is_bifurcating(), "Tree is not bifurcating: cannot handle"
        nadjusted = 0
        for node in tree.get_terminals() + tree.get_nonterminals():
            if node.branch_length < args['minbrlen']:
                nadjusted += 1
                node.branch_length = args['minbrlen']
        logger.info('Adjusted {0} branch lengths up to minbrlen {1}\n'.format(
                nadjusted, args['minbrlen']))

        # set up tree likelihood
        logger.info('Initializing TreeLikelihood..')
        tl = phydmslib.treelikelihood.TreeLikelihood(tree, alignment, model)
        logger.info('TreeLikelihood initialized.')

        # maximize likelihood
        logger.info('Maximizing log likelihood (initial value {0:.2f})...'.format(
                tl.loglik))
        if args['profile']:
            import cProfile
            import pstats
            pstatsfile = '{0}_pstats'.format(args['outprefix'])
            logger.info('Performing maximization with cProfile (probably slower).')
            logger.info('Profile stats will be written to {0}'.format(pstatsfile))
            maxresult = []
            def wrapper(maxresult): # wrapper to get return value from cProfile
                maxresult.append(tl.maximizeLikelihood())
            cProfile.runctx('wrapper(maxresult)', globals(), locals(), pstatsfile)
            maxresult = maxresult[0]
            for psort in ['cumulative', 'tottime']:
                fname = '{0}_{1}.txt'.format(pstatsfile, psort)
                logger.info('Writing profile stats sorted by {0} to {1}'.format(
                        psort, fname))
                f = open(fname, 'w')
                s = pstats.Stats(pstatsfile, stream=f)
                s.strip_dirs()
                s.sort_stats(psort)
                s.print_stats()
                f.close()
        else:
            maxresult = tl.maximizeLikelihood()
        logger.info('Maximization complete. New log likelihood is {0:.2f}.'.format(
                tl.loglik))
        logger.info('Here are optimization results:\n{0}'.format(maxresult))

        logging.shutdown() # debugging
        sys.exit(0) # debugging
        raise RuntimeError('only implemented to this far') # debugging

        # get number of cpus for multiprocessing
        if args['ncpus'] == -1:
            try:
                args['ncpus'] = multiprocessing.cpu_count()
            except:
                raise RuntimeError("Problem trying to determine number of available CPUs. Please manually specify the number of desired CPUs with '--ncpus' and try again.")
        logger.info("Using %d CPUs for the remaining computations.\n" % args['ncpus'])
        assert args['ncpus'] >= 1, "Failed to specify a number of CPUs that exceeds one: %d." % args['ncpus']

        # optimize a different omega for each site
        if args['omegabysite']:
            fixedomegavalue = 1.0 # null model fixes omega to this value
            excludeparams = ['omega', 'p', 'q', 'omegas', 'p0', 'delta1', 'delta2', 'omega0', 'omega2', 'theta1', 'theta2'] # parameters related to omega, do not fix
            fixedmodelparams = {}
            for (param, value) in allmodelparams.items():
                for excludeparam in excludeparams:
                    if excludeparam == param:
                        break
                else:
                    fixedmodelparams[param] = value
            logger.info('Now optimizing a different omega for each site while keeping branch lengths and other model parameters fixed.')
            if args['omegabysite_fixsyn']:
                fixsyn_string = "Using '--omegabysite_fixsyn', so the synonymous rate is assumed equal across all sites. This means we compare fitting omega for a site to not fitting anything."
            else:
                fixsyn_string = "Not using '--omegabysite_fixsyn', so we fit a synonymous rate for each site. This means we compare fitting omega and a synonymous rate to fitting just a synonymous rate."
            logger.info(fixsyn_string)
            logger.info('The tree and branch lengths will be fixed to the values in %s' % treefile)
            logger.info('The remaining model parameters will be to fixed to the following:\n\t%s\n' % '\n\t'.join(['%s = %g' % tup for tup in fixedmodelparams.items()]))
            if isinstance(model, str) and 'YNGKP' in model:
                aaprefs = {}
            fitomegaresults = FitOmegaBySitePool(codons, seqnames, seqs, aaprefs, model, fixedmodelparams, fixedomegavalue, treefile, args['recursion'], args['ncpus'], logger, args['omegabysite_fixsyn'], args['useLog'], ngammarates, args['ncats'], args['fixationmodel'])
            fitomegaresults = [(d['P'], site, d['omega'], d['dLnL']) for (site, d) in fitomegaresults.items()]
            fitomegaresults.sort()
            logger.info('Now writing the full results of the omega-by-site analysis to %s\n' % omegafile)
            with open(omegafile, 'w') as f:
                f.write("# Omega fit to each site after fixing tree and and all other parameters.\n# %s\n# Fits compared to null model of omega = %.3f; P-values NOT corrected for multiple testing.\n#\n# site\tomega\tP\tdLnL\n%s" % (fixsyn_string, fixedomegavalue, '\n'.join(['%d\t%.3f\t%.3g\t%.3f' % (site, omega, p, lnl) for (p, site, omega, lnl) in fitomegaresults])))

    except:
        logger.exception('Terminating %s at %s with ERROR' % (prog, time.asctime()))
        raise
    else:
        logger.info('Successful completion of %s' % prog)
    finally:
        logging.shutdown()



if __name__ == '__main__':
    main() # run the script
