#!python

"""Phylogenetic inference using deep mutational scanning data.

Written by Jesse Bloom."""


import sys
import os
import re
import logging
import random
import tempfile
import time
import math
import scipy.stats
import Bio.SeqRecord
import Bio.Phylo
import Bio.Phylo.TreeConstruction
import Bio.Seq
import Bio.Alphabet
import Bio.Alphabet.IUPAC
import Bio.Align
import dms_tools.file_io
import dms_tools.utils
import phydmslib
import phydmslib.file_io
import phydmslib.parsearguments
import phydmslib.pybpp
import phydmslib.mcmc


def main():
    """Main body of script."""

    # some regular expressions used later
    yngkp_match = re.compile('^YNGKP_M(?P<modelvariant>[0,3,7,8])$')

    # Parse command line arguments
    parser = phydmslib.parsearguments.PhyDMSParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    # create output directory if needed
    outdir = os.path.dirname(args['outprefix'])
    if outdir:
        if not os.path.isdir(outdir):
            if os.path.isfile(outdir):
                os.remove(outdir)
            os.mkdir(outdir)

    # name files, remove if they already exist
    modelparamsfile = '%s_modelparams.txt' % args['outprefix']
    loglikelihoodfile = '%s_loglikelihood.txt' % args['outprefix']
    treefile = "%s_tree.newick" % args['outprefix']
    omegafile = '%s_omegabysite.txt' % args['outprefix']
    stringencyfile = '%s_stringencybysite.txt' % args['outprefix']
    diffprefsfile = '%s_diffprefsbysite.txt' % args['outprefix']
    logfile = "%s.log" % args['outprefix']
    if args['no_optimize']:
        to_remove = [omegafile, stringencyfile, diffprefsfile, logfile]
        assert args['tree'] == treefile, "When using --no_optimize, you must set 'tree' to the name of the file that would be expected to be created for this 'outprefix', which is %s in this case" % treefile
    else:
        to_remove = [modelparamsfile, loglikelihoodfile, treefile, omegafile, stringencyfile, diffprefsfile, logfile]
    for f in to_remove:
        if os.path.isfile(f):
            os.remove(f)

    # Set up to log everything to logfile.
    logging.shutdown()
    versionstring = phydmslib.file_io.Versions() 
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)

    # begin execution
    try:

        # print some basic information
        logger.info('Beginning execution of %s in directory %s\n' % (prog, os.getcwd()))
        logger.info('Progress is being logged to %s\n' % logfile)
        logger.info("%s\n" % versionstring)
        logger.info('Parsed the following command-line arguments:\n%s\n' % '\n'.join(['\t%s = %s' % tup for tup in args.iteritems()]))

        logger.info('Seeding random number generator with %d\n' % args['seed'])
        random.seed(args['seed'])

        # some checks on arguments
        if args['tree'] == 'random' and not args['infertopology']:
            raise ValueError("It does not make sense to use ``tree`` of *random* without also using ``--infertopology``")
        if args['fixbrlen'] and args['infertopology']:
            raise ValueError("It does not make sense to ``--fixbrlen`` with ``--infertopology``")
        if args['addrateparameter'] and not args['fixbrlen']:
            raise ValueError("It does not make sense to use --addrateparameter without also using --fixbrlen, as otherwise branch lengths are already scaled by rate.")

        # read alignment
        logger.info('Reading alignment from %s' % args['alignment'])
        alignment = phydmslib.file_io.ReadCodonAlignment(args['alignment'], checknewickvalid=True)
        seqnames = set([head for (head, seq) in alignment])
        logger.info('Read %d aligned codon sequences from %s. Each sequences consists of %d codons.\n' % (len(alignment), args['alignment'], len(alignment[0][1]) // 3))

        # process the substitution model
        if isinstance(args['model'], str) and yngkp_match.search(args['model']):
            for argname in ['stringencybysite', 'diffprefsbysite', 'randprefs', 'avgprefs']:
                if args[argname]:
                    raise ValueError("You can use '--%s' only with an ExpCM model" % argname)
            modelvariant = yngkp_match.search(args['model']).group('modelvariant')
            if args['infertopology'] and int(modelvariant) != 0:
                raise ValueError("You cannot use '--infertopology' with model %s" % args['model'])
            logger.info('The codon substitution model with be the M%s version of YNGKP (Yang, Nielsen, Goldman, and Pederson. Genetics. 155:431-449).' % modelvariant)
            if args['fitF3X4']:
                logger.info('The codon equilibrium frequencies will be set by F3X4, optimizing the nine nucleotide frequencies by maximum likelihood.\n')
                model = args['model'] + '_fitF3X4'
            else:
                logger.info('The codon equilibrium frequencies will be set by F3X4, estimating the nine nucleotide frequencies empirically from the alignment frequencies.\n')
                model = args['model'] + '_empF3X4'
        elif isinstance(args['model'], tuple) and len(args['model']) == 2 and args['model'][0] == 'ExpCM':
            assert not args['infertopology'], "You cannot use '--infertopology' with ExpCM"
            assert not args['fitF3X4'], "You cannot use '--fitF3X4' with ExpCM"
            prefsfilename = args['model'][1]
            logger.info('The codon substitution model will be experimentally informed model by the site-specific amino-acid preferences in %s' % prefsfilename)
            (sites, wts, pi_means, pi_95credint, h) = dms_tools.file_io.ReadPreferences(prefsfilename)
            if len(sites) != len(alignment[0][1]) // 3:
                raise ValueError("The number of amino-acid preferences in %s does not match the number of codon sites in the alignment" % prefsfilename)
            if not all([r.isdigit() for r in sites]):
                raise ValueError("All sites in preferences file must be integers")
            sites = [int(r) for r in sites]
            assert len(set(sites)) == len(sites), "There are non-unique sites in the preferences file"
            if not (min(sites) == 1 and max(sites) - min(sites) == len(sites) - 1):
                raise ValueError("Sites in preferences file must start at 1 and be consecutive")
            pi_means = dms_tools.utils.RemoveStopFromPreferences(pi_means)
            aas = pi_means['1'].keys()
            if set(aas) != set(Bio.Alphabet.IUPAC.IUPACProtein.letters):
                raise ValueError("Preferences are not specified for the 20 amino acids")
            assert all([set(aas) == set(ipi.keys()) for ipi in pi_means.values()]), "Not same amino acid keys for all sites"
            aaprefs = dict([(int(r), rprefs) for (r, rprefs) in pi_means.items()])
            logger.info('Successfully read site-specific amino-acid preferences for all %d sites.\n' % len(aaprefs))
            if args['randprefs']:
                assert not args['avgprefs'], "Cannot use both '--randprefs' and '--avgprefs'"

                logger.info("Now randomizing these amino-acid preferences among sites.\n")
                rs = [r for r in aaprefs.keys()]
                aaprefs = [rprefs for rprefs in aaprefs.values()]
                random.shuffle(rs)
                aaprefs = dict(zip(rs, aaprefs))
            elif args['avgprefs']:
                assert not args['randprefs'], "Cannot use both '--randprefs' and '--avgprefs'"
                logger.info("Now averaging these amino-acid preferences across sites.\n")
                avg_prefs = dict([(aa, 0.0) for aa in aas])
                for rprefs in aaprefs.values():
                    for aa in aas:
                        avg_prefs[aa] += rprefs[aa]
                for aa in aas:
                    avg_prefs[aa] /= float(len(aaprefs))
                for r in aaprefs.keys():
                    aaprefs[r] = avg_prefs
            model = ('ExpCM', aaprefs)
        else:
            raise ValueError("Invalid model of %s" % args['model'])

        # read or create the tree
        if args['tree'] == 'random':
            assert not args['no_optimize'], "Cannot use --no_optimize with tree of 'random'"
            logger.info("Creating a random initial tree.")
            tree = Bio.Phylo.BaseTree.Tree.randomized(seqnames, branch_length=1.0)
        elif args['tree'] == 'nj':
            assert not args['no_optimize'], "Cannot use --no_optimize with tree of 'nj'"
            logger.info('Creating an initial tree from nucleotide sequences by neighbor joining using a crude identity scoring matrix...')
            msa = Bio.Align.MultipleSeqAlignment([Bio.SeqRecord.SeqRecord(Bio.Seq.Seq(seq, Bio.Alphabet.generic_dna), id=head) for (head, seq) in alignment])
            calculator = Bio.Phylo.TreeConstruction.DistanceCalculator('identity')
            tree = Bio.Phylo.TreeConstruction.DistanceTreeConstructor(calculator, 'nj').build_tree(msa)
            logger.info("Finished creating a crude neighbor-joining initial tree.")
        else:
            logger.info("Reading tree from %s" % args['tree'])
            tree = Bio.Phylo.read(args['tree'], 'newick')
        tipnames = set([clade.name for clade in tree.get_terminals()])
        if tipnames != seqnames:
            raise ValueError("The sequence names in alignment do not match those in tree.\nSequences in alignment but NOT in tree:\n\t%s\nSequences in tree but NOT in alignment:\n\t%s" % ('\n\t'.join(seqnames - tipnames), '\n\t'.join(tipnames - seqnames)))
        logger.info('This tree has %d tips nodes, matching the sequences in alignment.' % len([clade.name for clade in tree.get_terminals()]))
        nadjustedbrlen = 0
        for node in tree.get_terminals() + tree.get_nonterminals():
            if node != tree.root and node.branch_length < args['minbrlen']:
                node.branch_length = args['minbrlen']
                nadjustedbrlen += 1
        if nadjustedbrlen:
            logger.info('Ensured that all branch lengths are >= minimum of %g by adjusting %d lengths up to this value.\n' % (args['minbrlen'], nadjustedbrlen))
        else:
            logger.info('Confirmed that all branch lengths are >= minimum of %g.\n' % args['minbrlen'])
        newicktree = tree.format('newick').strip()
        # remove internal node names because they cause problem in parsing tree later
        for node in tree.get_nonterminals():
            if node.name: # root node won't have name
                toremove = ')' + node.name + ':'
                assert toremove in newicktree, "Cannot find internal node %s in form %s in tree:\n%s" % (node.name, toremove, newicktree)
                newicktree = newicktree.replace(toremove, '):')
        seqnames = [head for (head, seq) in alignment]
        seqs = [seq for (head, seq) in alignment]

        # now optimize tree 
        if args['no_optimize']:
            require_files = [modelparamsfile, loglikelihoodfile, treefile]
            logger.info("Because --no_optimize is being used, the tree and model parameters will not be optimized. Instead using the existing values from a previous optimization in the following files: %s\n" % ', '.join(require_files))
            if not all([os.path.isfile(f) for f in require_files]):
                raise ValueError("Cannot use --no_optimize' because cannot find all of the existing optimization files: %s" % ', '.join(require_files))
            tl = phydmslib.pybpp.PyBppTreeLikelihood(seqnames, seqs, treefile, model, args['infertopology'], fixedmodelparams={}, initializemodelparams={}, oldlikelihoodmethod=False, fixbrlen=args['fixbrlen'], addrateparameter=args['addrateparameter'], recursion=args['recursion'])
            with open(modelparamsfile) as f:
                modelparams = dict([(line.split('=')[0].strip(), float(line.split('=')[1])) for line in f])
            allmodelparams = modelparams
            if set(tl.ModelParams(False).keys()) != set(modelparams.keys()):
                raise ValueError("The existing model params file %s does not have all of the expected parameters for this substitution model, so cannot use --no_optimize. Either the existing model parameters were created with a different model, or you used a YNGKP model without --fitF3X4 (this is currently incompatible with --no_optimize).")
        else:
            try:
                (fd, temptreefile) = tempfile.mkstemp() # create temporary file to write tree for passing
                with os.fdopen(fd, 'w') as f:
                    f.write(newicktree)
                if isinstance(model, str) and 'YNGKP' in model:
                    oldlikelihoodmethod = True
                else:
                    oldlikelihoodmethod = False
                logger.info('Creating Bio++ object to optimize likelihood...')
                tl = phydmslib.pybpp.PyBppTreeLikelihood(seqnames, seqs, temptreefile, model, args['infertopology'], fixedmodelparams={}, initializemodelparams={}, oldlikelihoodmethod=oldlikelihoodmethod, fixbrlen=args['fixbrlen'], addrateparameter=args['addrateparameter'], recursion=args['recursion'])
            finally:
                if os.path.isfile(temptreefile):
                    os.remove(temptreefile)
            logger.info('Created Bio++ object to optimize likelihood for the %d codon sites of the %d sequences.\n' % (tl.NSites(), tl.NSeqs()))
            logger.info('The initial log likelihood is %g; now optimizing by maximum likelihood...' % tl.LogLikelihood())
            tl.OptimizeLikelihood()
            logger.info('Completed optimizing by maximum likelihood.')
            logger.info("Here is the optimized log likelihood (also being written to %s): %g." % (loglikelihoodfile, tl.LogLikelihood()))
            with open(loglikelihoodfile, 'w') as f:
                f.write('log likelihood = %g' % tl.LogLikelihood())
            modelparams = tl.ModelParams(True)
            modelparamstextlist = ['%s = %g' % tup for tup in modelparams.items()]
            modelparamstextlist.sort()
            logger.info("Here are the optimized model parameters (also being written to %s):\n\t%s" % (modelparamsfile, '\n\t'.join(modelparamstextlist)))
            with open(modelparamsfile, 'w') as f:
                f.write('\n'.join(modelparamstextlist))
            logger.info("Here is the optimized tree (also being written to %s):\n%s" % (treefile, tl.NewickTree()))
            with open(treefile, 'w') as f:
                f.write(tl.NewickTree())
            allmodelparams = tl.ModelParams(False)
            del tl

        # optimize a different omega for each site
        if args['omegabysite']:
            fixedomegavalue = 1.0 # null model fixes omega to this value
            excludeparams = ['omega', 'p', 'q', 'omegas', 'p0', 'delta1', 'delta2', 'omega0', 'theta1', 'theta2'] # parameters related to omega, do not fix
            fixedmodelparams = {}
            for (param, value) in allmodelparams.items():
                for excludeparam in excludeparams:
                    if excludeparam == param:
                        break
                else:
                    fixedmodelparams[param] = value
            logger.info('Now optimizing a different omega for each site while keeping branch lengths and other model parameters fixed (but adding a rate parameter that effectively scales the branch lengths).')
            logger.info('The tree and branch lengths will be fixed to the values in %s' % treefile)
            logger.info('The model parameters (other than omega and the rate) will be to fixed to the following:\n\t%s\n' % '\n\t'.join(['%s = %g' % tup for tup in fixedmodelparams.items()]))
            fitomegaresults = {} # keyed by site, values dict with results for site
            for icodon in range(1, len(seqs[0]) // 3 + 1):
                fitomegaresults[icodon] = {}
                logger.info('Fitting models for site %d with omega as a free parameter and fixed to %.2f.' % (icodon, fixedomegavalue))
                if model[ : 7] == 'YNGKP_M':
                    imodel = 'YNGKP_M0_fitF3X4' # single omega for the site, M0 model
                elif isinstance(model, tuple) and model[0] == 'ExpCM':
                    imodel = ('ExpCM', {1:aaprefs[icodon]})
                else:
                    raise ValueError("Invalid model")
                iseqs = [seq[3 * icodon  - 3 : 3 * icodon] for seq in seqs]
                for fitomega in ['fitted', 'fixed']:
                    ifixedmodelparams = dict([(param, value) for (param, value) in fixedmodelparams.items()])
                    if fitomega == 'fixed':
                        ifixedmodelparams['omega'] = fixedomegavalue
                        initializemodelparams = {}
                    else:
                        initializemodelparams = {'omega':fixedomegavalue}
                    tl = phydmslib.pybpp.PyBppTreeLikelihood(seqnames, iseqs, treefile, imodel, infertopology=False, fixedmodelparams=ifixedmodelparams, initializemodelparams=initializemodelparams, oldlikelihoodmethod=False, fixbrlen=True, addrateparameter=True, recursion=args['recursion']) 
                    tl.OptimizeLikelihood()
                    fitomegaresults[icodon]["LnL_%s" % fitomega] = tl.LogLikelihood()
                    if fitomega == 'fitted':
                        fitomegaresults[icodon]['omega'] = tl.ModelParams(True)['omega']
                fitomegaresults[icodon]['dLnL'] = fitomegaresults[icodon]['LnL_fitted'] - fitomegaresults[icodon]['LnL_fixed']
                fitomegaresults[icodon]['P'] = scipy.stats.chi2.sf(2.0 * fitomegaresults[icodon]['dLnL'], df=1)
                logger.info('Fitting omega to %.2f increases LnL by %.2f relative to fixing omega at %.2f (P-value %.2g).\n' % (fitomegaresults[icodon]['omega'], fitomegaresults[icodon]['dLnL'], fixedomegavalue, fitomegaresults[icodon]['P']))
            fitomegaresults = [(d['P'], site, d['omega'], d['dLnL']) for (site, d) in fitomegaresults.items()]
            fitomegaresults.sort()
            logger.info('Now writing the full results of the omega-by-site analysis to %s\n' % omegafile)
            with open(omegafile, 'w') as f:
                f.write("# Omega fit to each site after fixing tree and and all other parameters.\n# Fits compared to null model of omega = %.2f; P-values NOT corrected for multiple testing.\n#\n# site\tomega\tP\tdLnL\n%s" % (fixedomegavalue, '\n'.join(['%d\t%.2f\t%.2g\t%.2f' % (site, omega, p, lnl) for (p, site, omega, lnl) in fitomegaresults])))

        # optimize a different stringency parameter for each site
        if args['stringencybysite']:
            assert isinstance(model, tuple) and model[0] == 'ExpCM', "stringencybysite only allowed for ExpCM"
            fixedstringencyvalue = modelparams['stringencyparameter'] # null model fixes stringency to this value
            fixedmodelparams = dict([(param, value) for (param, value) in allmodelparams.items() if param != 'stringencyparameter'])
            logger.info('Now optimizing a different stringency parameter for each site while keeping branch lengths and other model parameters fixed. This will be compared to a null model where the stringency parameter is equal to the overall gene value of %.2f.' % fixedstringencyvalue)
            logger.info('The tree and branch lengths will be fixed to the values in %s' % treefile)
            logger.info('The model parameters (other than the stringency parameter) will be to fixed to the following:\n\t%s\n' % '\n\t'.join(['%s = %g' % tup for tup in fixedmodelparams.items()]))
            fitstringencyresults = {} # keyed by site
            for icodon in range(1, len(seqs[0]) // 3 + 1):
                fitstringencyresults[icodon] = {}
                logger.info('Fitting models for site %d with stringency as a free parameter and fixed to %.2f.' % (icodon, fixedstringencyvalue))
                iseqs = [seq[3 * icodon  - 3 : 3 * icodon] for seq in seqs]
                for fitstringency in ['fitted', 'fixed']:
                    ifixedmodelparams = dict([(param, value) for (param, value) in fixedmodelparams.items()])
                    if fitstringency == 'fixed':
                        initializemodelparams = {}
                        ifixedmodelparams['stringencyparameter'] = fixedstringencyvalue
                    else:
                        initializemodelparams = {'stringencyparameter':fixedstringencyvalue}
                    imodel = ('ExpCM', {1:aaprefs[icodon]})
                    tl = phydmslib.pybpp.PyBppTreeLikelihood(seqnames, iseqs, treefile, imodel, infertopology=False, fixedmodelparams=ifixedmodelparams, initializemodelparams=initializemodelparams, oldlikelihoodmethod=False, fixbrlen=True, addrateparameter=False, recursion=args['recursion']) 
                    tl.OptimizeLikelihood()
                    fitstringencyresults[icodon]["LnL_%s" % fitstringency] = tl.LogLikelihood()
                    if fitstringency == 'fitted':
                        fitstringencyresults[icodon]['stringency'] = tl.ModelParams(True)['stringencyparameter']
                        fitstringencyresults[icodon]['stringency_ratio'] = fitstringencyresults[icodon]['stringency'] / fixedstringencyvalue
                fitstringencyresults[icodon]['dLnL'] = fitstringencyresults[icodon]['LnL_fitted'] - fitstringencyresults[icodon]['LnL_fixed']
                fitstringencyresults[icodon]['P'] = scipy.stats.chi2.sf(2.0 * fitstringencyresults[icodon]['dLnL'], df=1)
                logger.info('Fitting a stringency ratio of %.2f (fitted value of %.2f versus gene value of %.2f) increases LnL by %.2f (P-value %.2g).\n' % (fitstringencyresults[icodon]['stringency_ratio'], fitstringencyresults[icodon]['stringency'], fixedstringencyvalue, fitstringencyresults[icodon]['dLnL'], fitstringencyresults[icodon]['P']))
            fitstringencyresults = [(d['P'], site, d['stringency_ratio'], d['dLnL']) for (site, d) in fitstringencyresults.items()]
            fitstringencyresults.sort()
            logger.info('Now writing the full results of the stringency-by-site analysis to %s\n' % stringencyfile)
            with open(stringencyfile, 'w') as f:
                f.write("# Stringency fit to each site after fixing tree and and all other parameters.\n# Fits compared to null model of stringency = %.2f (the overall gene value).\n# P-values NOT corrected for multiple testing.\n# The stringency ratio is the ratio of the fitted value to the null (overall gene value).\n#\n# site\tstringency_ratio\tP\tdLnL\n%s" % (fixedstringencyvalue, '\n'.join(['%d\t%.2f\t%.2g\t%.2f' % (site, stringencyratio, p, lnl) for (p, site, stringencyratio, lnl) in fitstringencyresults])))

        if args['diffprefsbysite']:
            assert isinstance(model, tuple) and model[0] == 'ExpCM', "diffprefsbysite only allowed for ExpCM"
            fixedmodelparams = dict([(param, value) for (param, value) in allmodelparams.items() if param != 'stringencyparameter'])
            fixedmodelparams['stringencyparameter'] = 1.0
            logger.info('Now inferring the difference between the preferences specified in %s and those that best describe the natural evolution. We perform MCMC with a Dirichlet prior centered on the preferences provided in the file with a concentration parameter of %.2f. The preferences in the file are rescaled prior to this inference by the stringency parameter value of %.2f previously optimized for the entire sequence / tree, and the difference in preferences are relative to these rescaled preferences. After this rescaling, the stringency parameter is set to one. All other model parameters are fixed to their maximum likelihood values for the entire sequence / tree.' % (prefsfilename, args['diffprefsalpha'], modelparams['stringencyparameter']))
            logger.info('The tree and branch lengths will be fixed to the values in %s' % treefile)
            logger.info('The model parameters will be to fixed to the following:\n\t%s\n' % '\n\t'.join(['%s = %g' % tup for tup in fixedmodelparams.items()]))
            for icodon in range(1, len(seqs[0]) // 3 + 1):
                logger.info('Inferring difference in preferences for site %d...' % icodon)
                iseqs = [seq[3 * icodon  - 3 : 3 * icodon] for seq in seqs]
                stringencyscaledprefs = dict([(aa, pref**modelparams['stringencyparameter']) for (aa, pref) in aaprefs[icodon].items()])
                prefsum = float(sum(stringencyscaledprefs.values()))
                stringencyscaledprefs = dict([(aa, pref / prefsum) for (aa, pref) in stringencyscaledprefs.items()])
                imodel = ('ExpCM', {1:stringencyscaledprefs})
                tl = phydmslib.pybpp.PyBppTreeLikelihood(seqnames, iseqs, treefile, imodel, infertopology=False, fixedmodelparams=fixedmodelparams, initializemodelparams={}, oldlikelihoodmethod=False, fixbrlen=True, addrateparameter=False, recursion=args['recursion']) 
                initial_ll = tl.LogLikelihood()
                (meanprefs, mcmcstring, converged) = phydmslib.mcmc.PrefsMCMC(tl, stringencyscaledprefs, site=1, concentrationparam=args['diffprefsalpha'], seed=args['seed'])
                if not converged:
                    raise RuntimeError("MCMC failed to converge for site %d. Here is the MCMC message:\n%s" % (icodon, mcmcstring))
                tl.SetPreferences(meanprefs, 1)
                diffprefs = dict([(x, meanprefs[x] - stringencyscaledprefs[x]) for x in meanprefs.keys()])
                rmsdiffpref = math.sqrt(sum([x**2 for x in diffprefs.values()]))
                new_ll = tl.LogLikelihood()
                assert (new_ll - initial_ll) > -1, "Log likelihood of %g with posterior mean prefs is substantially greater than initial log likelihood of %g for site %d. This probably indicates a problem with the MCMC." % (new_ll, initial_ll, icodon)
                logger.info("For site %d, the increase in log likelihood is %.3g when going from the initial preferences to those inferred from natural evolution. Here is information about the MCMC:\n\t%s" % (icodon, new_ll - initial_ll, mcmcstring))
                logger.info("The RMS difference in preference is %.3f; here are the differences in preferences for each amino acid: %s\n" % (rmsdiffpref, ', '.join(['%s = %.3f' % tup for tup in diffprefs.items()])))

    except:
        logger.exception('Terminating %s at %s with ERROR' % (prog, time.asctime()))    
        raise
    else:
        logger.info('Successful completion of %s' % prog)
    finally:
        logging.shutdown()



if __name__ == '__main__':
    main() # run the script
