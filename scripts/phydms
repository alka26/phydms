#!python

"""Phylogenetic inference using deep mutational scanning data.

Written by Jesse Bloom."""


import sys
import os
import re
import logging
import random
import tempfile
import time
import math
import multiprocessing
import Bio.SeqRecord
import Bio.Phylo
import Bio.Seq
import Bio.Align
import phydmslib
import phydmslib.constants
import phydmslib.file_io
import phydmslib.parsearguments
import phydmslib.models


    
def ReadDivPressure(fileName):
    """Read diversifying pressure, return dict of sites and diversifying pressure."""
    with open(fileName) as f:
        lines = [line for line in f.readlines() if (not line.isspace()) and line[0] != '#']
        divPressure = {}
        for line in lines:
            entries = line.split()
            try:
                assert len(entries) ==2
                site = int(entries[0])
                divValue = float(entries[1])
            except:
                raise ValueError("Not an integer followed by a float in line of {0}: \n{1}".format(fileName,line))
            assert site not in divPressure, "Duplicate diversifying pressure specified for site {0}".format(site)
            divPressure[site] = divValue
    return divPressure


def main():
    """Main body of script."""

    # Parse command line arguments
    parser = phydmslib.parsearguments.PhyDMSParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    # create output directory if needed
    outdir = os.path.dirname(args['outprefix'])
    if outdir:
        if not os.path.isdir(outdir):
            if os.path.isfile(outdir):
                os.remove(outdir)
            os.mkdir(outdir)

    # name files, remove if they already exist
    modelparamsfile = '%s_modelparams.txt' % args['outprefix']
    loglikelihoodfile = '%s_loglikelihood.txt' % args['outprefix']
    treefile = "%s_tree.newick" % args['outprefix']
    omegafile = '%s_omegabysite.txt' % args['outprefix']
    logfile = "%s.log" % args['outprefix']
    to_remove = [modelparamsfile, loglikelihoodfile, treefile, omegafile, logfile]
    for f in to_remove:
        if os.path.isfile(f):
            os.remove(f)

    # Set up to log everything to logfile.
    logging.shutdown()
    logging.captureWarnings(True)
    versionstring = phydmslib.file_io.Versions() 
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', 
            level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)

    # begin execution
    try:
        # print some basic information
        logger.info('Beginning execution of {0} in directory {1}\n'.format(
                prog, os.getcwd()))
        logger.info('Progress is being logged to {0}\n'.format(logfile))
        logger.info("{0}\n".format(versionstring))
        logger.info('Parsed the following arguments:\n{0}\n'.format(
                '\n'.join(['\t{0} = {1}'.format(*tup) for tup in args.items()])))
        logger.info('Random number seed: {0}\n'.format(args['seed']))
        random.seed(args['seed'])

        # read alignment
        logger.info('Reading alignment from {0}'.format(args['alignment']))
        alignment = phydmslib.file_io.ReadCodonAlignment(args['alignment'], 
                checknewickvalid=True)
        logger.info(('Read {0} aligned sequences from {1}, each consisting '
                'of {2} codons.\n').format(len(alignment), args['alignment'], 
                len(alignment[0][1]) // 3))

        # process the substitution model
        yngkp_match = re.compile('^YNGKP_M(?P<modelvariant>\d+)$')
        if isinstance(args['model'], str) and yngkp_match.search(args['model']):
            raise RuntimeError('YNGKP models not yet implemented')
            for argname in ['randprefs', 'avgprefs', 'divpressure']:
                assert not args[argname], "'--%s' incompatible with YNKGP".format(
                            argname)
            modelvariant = yngkp_match.search(args['model']).group('modelvariant')
            logger.info(('The codon substitution model with be the M{0} version '
                    'of YNGKP (Yang, Nielsen, Goldman, and Pederson. Genetics. '
                    '155:431-449).').format(modelvariant))
        elif (isinstance(args['model'], tuple) and len(args['model']) == 2 and 
                args['model'][0] == 'ExpCM'):
            prefsfile = args['model'][1]
            logger.info(('The ExpCM will be informed by the site-specific '
                    'amino-acid preferences in {0}').format(prefsfile))
            for (argname, desc) in [('avgprefs', 'averaged'), 
                    ('randprefs', 'randomized')]:
                logger.info('Preferences will be {0} across sites.'.format(desc))
            prefs = phydmslib.file_io.readPrefs(prefsfile, minpref=args['minpref'], 
                    avgprefs=args['avgprefs'], randprefs=args['randprefs'],
                    seed=args['seed'])
            sites = sorted(prefs.keys())
            prefslist = [prefs[r] for r in sites] # convert prefs from dict to list
            assert len(prefs) == len(alignment[0][1]) // 3, ("The number of "
                    "preferences in {0} does not match the number of codon "
                    "sites in the alignment").format(prefsfile)
            logger.info(('Successfully read site-specific amino-acid preferences '
                    'for all {0} sites.\n').format(len(prefs)))
            freeparams = ['kappa', 'omega', 'beta', 'eta']
            if args['brlen'] == 'scale':
                freeparams.append('mu')
            model = phydmslib.models.ExpCM(prefslist, freeparams=freeparams)

            # read diversifying pressure
            if False: # not yet implemented, so skip code
            #if args['divpressure']:
                raise RuntimeError('--divpressure not yet implemented')
                for otherarg in ['omegabysite']:
                    if args[otherarg]:
                        raise ValueError("Can't use --divpressure and --{0}".format(
                                otherarg))
                divpressure = ReadDivPressure(args['divpressure'])
                assert set(divpressure.keys()) == set(sites), ("The site labels "
                        "not the same for diversifying pressure and preferences")
                logger.info(('Successfully read diversifying pressure from {0} '
                        'for all sites.').format(args['divpressure']))

        else:
            raise ValueError("Invalid model of %s" % args['model'])

        raise RuntimeError('current implementation stops here')
        # read or create the tree
        if args['tree'] == 'random':
            assert not args['no_optimize'], "Cannot use --no_optimize with tree of 'random'"
            logger.info("Creating a random initial tree.")
            tree = Bio.Phylo.BaseTree.Tree.randomized(seqnames, branch_length=1.0)
        elif args['tree'] == 'nj':
            assert not args['no_optimize'], "Cannot use --no_optimize with tree of 'nj'"
            logger.info('Creating an initial tree from nucleotide sequences by neighbor joining using a crude identity scoring matrix...')
            msa = Bio.Align.MultipleSeqAlignment([Bio.SeqRecord.SeqRecord(Bio.Seq.Seq(seq, Bio.Alphabet.generic_dna), id=head) for (head, seq) in alignment])
            calculator = Bio.Phylo.TreeConstruction.DistanceCalculator('identity')
            tree = Bio.Phylo.TreeConstruction.DistanceTreeConstructor(calculator, 'nj').build_tree(msa)
            logger.info("Finished creating a crude neighbor-joining initial tree.")
        else:
            logger.info("Reading tree from %s" % args['tree'])
            tree = Bio.Phylo.read(args['tree'], 'newick')
        tipnames = set([clade.name for clade in tree.get_terminals()])
        if tipnames != seqnames:
            raise ValueError("The sequence names in alignment do not match those in tree.\nSequences in alignment but NOT in tree:\n\t%s\nSequences in tree but NOT in alignment:\n\t%s" % ('\n\t'.join(seqnames - tipnames), '\n\t'.join(tipnames - seqnames)))
        logger.info('This tree has %d tips nodes, matching the sequences in alignment.' % len([clade.name for clade in tree.get_terminals()]))
        # next 4 lines necessary for biopython <= 1.66, which fails on trees with negative branch lengths
        for node in tree.get_terminals() + tree.get_nonterminals():
            if node != tree.root:
                node.branch_length = max(0, node.branch_length)
        # end of code necessary for tree parsing by biopython <= 1.66
        newicktree = tree.format('newick').strip()
        # remove internal node names because they cause problem in parsing tree later
        for node in tree.get_nonterminals():
            if node.name: # root node won't have name
                toremove = ')' + node.name + ':'
                assert toremove in newicktree, "Cannot find internal node %s in form %s in tree:\n%s" % (node.name, toremove, newicktree)
                newicktree = newicktree.replace(toremove, '):')
        seqnames = [head for (head, seq) in alignment]
        seqs = [seq for (head, seq) in alignment]

        # use old likelihood method for YNGPK models, new otherwise
        if isinstance(model, str) and 'YNGKP' in model:
            oldlikelihoodmethod = True
        else:
            oldlikelihoodmethod = False

        # now optimize tree 
        if args['no_optimize']:
            require_files = [modelparamsfile, loglikelihoodfile, treefile]
            logger.info("Because --no_optimize is being used, the tree and model parameters will not be optimized. Instead using the existing values from a previous optimization in the following files: %s\n" % ', '.join(require_files))
            if not all([os.path.isfile(f) for f in require_files]):
                raise ValueError("Cannot use --no_optimize' because cannot find all of the existing optimization files: %s" % ', '.join(require_files))
            with open(loglikelihoodfile) as f:
                old_ll = float(f.readlines()[0].split('=')[1])
            with open(modelparamsfile) as f:
                modelparams = dict([(line.split('=')[0].strip(), float(line.split('=')[1])) for line in f])
            allmodelparams = modelparams
            tl = phydmslib.pybpp.PyBppTreeLikelihood(seqnames, seqs, treefile, model, args['infertopology'], fixedmodelparams=modelparams, initializemodelparams={}, oldlikelihoodmethod=oldlikelihoodmethod, fixbrlen=True, addrateparameter=False, prefsasparams=False, recursion=args['recursion'], useLog=args['useLog'], ngammarates=ngammarates, ncats=args['ncats'])
            assert not tl.ModelParams(True), "There are unspecified model parameters to be optimized for --no_optimize: %s" % str(tl.ModelParams(True))
            if set(tl.ModelParams(False).keys()) != set(modelparams.keys()):
                raise ValueError("The existing model params file %s does not have all of the expected parameters for this substitution model, so cannot use --no_optimize. Either the existing model parameters were created with a different model, or you used a YNGKP model without --fitF3X4 (this is currently incompatible with --no_optimize).")
            if abs(tl.LogLikelihood() - old_ll) > 1:
                raise ValueError("Incompatibility between old log likelihood %g and new one of %g" % (old_ll, tl.LogLikelihood()))
        else:
            try:
                (fd, temptreefile) = tempfile.mkstemp() # create temporary file to write tree for passing
                with os.fdopen(fd, 'w') as f:
                    f.write(newicktree)
                logger.info('Adjusting all branch lengths to >= {0}.\n'.format(args['minbrlen']))
                phydmslib.file_io.SetMinBrLen(temptreefile, temptreefile, args['minbrlen'])
                logger.info('Creating Bio++ object to optimize likelihood...')
                tl = phydmslib.pybpp.PyBppTreeLikelihood(seqnames, seqs, temptreefile, model, args['infertopology'], fixedmodelparams={}, initializemodelparams={}, oldlikelihoodmethod=oldlikelihoodmethod, fixbrlen=args['fixbrlen'], addrateparameter=args['addrateparameter'], prefsasparams=False, recursion=args['recursion'], useLog=args['useLog'], ngammarates=ngammarates, ncats=args['ncats'])
            finally:
                if os.path.isfile(temptreefile):
                    os.remove(temptreefile)
            logger.info('Created Bio++ object to optimize likelihood for the %d codon sites of the %d sequences.\n' % (tl.NSites(), tl.NSeqs()))
            logger.info('The initial log likelihood is %g; now optimizing by maximum likelihood...' % tl.LogLikelihood())
            tl.OptimizeLikelihood()
            logger.info('Completed optimizing by maximum likelihood.')
            logger.info("Here is the optimized log likelihood (also being written to %s): %g." % (loglikelihoodfile, tl.LogLikelihood()))
            with open(loglikelihoodfile, 'w') as f:
                f.write('log likelihood = %g' % tl.LogLikelihood())
            modelparams = tl.ModelParams(True)
            modelparamstextlist = ['%s = %.6f' % tup for tup in modelparams.items()]
            modelparamstextlist.sort()
            logger.info("Here are the optimized model parameters (also being written to %s):\n\t%s" % (modelparamsfile, '\n\t'.join(modelparamstextlist)))
            with open(modelparamsfile, 'w') as f:
                f.write('\n'.join(modelparamstextlist))
            logger.info("Here is the optimized tree (also being written to %s):\n%s\n" % (treefile, tl.NewickTree()))
            with open(treefile, 'w') as f:
                f.write(tl.NewickTree())
            allmodelparams = tl.ModelParams(False)
        del tl

        # list of all codons
        codons = [icodon for icodon in range(1, len(seqs[0]) // 3 + 1)]

        # get number of cpus for multiprocessing
        if args['ncpus'] == -1:
            try:
                args['ncpus'] = multiprocessing.cpu_count()
            except:
                raise RuntimeError("Problem trying to determine number of available CPUs. Please manually specify the number of desired CPUs with '--ncpus' and try again.")
        logger.info("Using %d CPUs for the remaining computations.\n" % args['ncpus'])
        assert args['ncpus'] >= 1, "Failed to specify a number of CPUs that exceeds one: %d." % args['ncpus']

        # optimize a different omega for each site
        if args['omegabysite']:
            fixedomegavalue = 1.0 # null model fixes omega to this value
            excludeparams = ['omega', 'p', 'q', 'omegas', 'p0', 'delta1', 'delta2', 'omega0', 'omega2', 'theta1', 'theta2'] # parameters related to omega, do not fix
            fixedmodelparams = {}
            for (param, value) in allmodelparams.items():
                for excludeparam in excludeparams:
                    if excludeparam == param:
                        break
                else:
                    fixedmodelparams[param] = value
            logger.info('Now optimizing a different omega for each site while keeping branch lengths and other model parameters fixed.')
            if args['omegabysite_fixsyn']:
                fixsyn_string = "Using '--omegabysite_fixsyn', so the synonymous rate is assumed equal across all sites. This means we compare fitting omega for a site to not fitting anything."
            else:
                fixsyn_string = "Not using '--omegabysite_fixsyn', so we fit a synonymous rate for each site. This means we compare fitting omega and a synonymous rate to fitting just a synonymous rate."
            logger.info(fixsyn_string)
            logger.info('The tree and branch lengths will be fixed to the values in %s' % treefile)
            logger.info('The remaining model parameters will be to fixed to the following:\n\t%s\n' % '\n\t'.join(['%s = %g' % tup for tup in fixedmodelparams.items()]))
            if isinstance(model, str) and 'YNGKP' in model:
                aaprefs = {}
            fitomegaresults = FitOmegaBySitePool(codons, seqnames, seqs, aaprefs, model, fixedmodelparams, fixedomegavalue, treefile, args['recursion'], args['ncpus'], logger, args['omegabysite_fixsyn'], args['useLog'], ngammarates, args['ncats'], args['fixationmodel'])
            fitomegaresults = [(d['P'], site, d['omega'], d['dLnL']) for (site, d) in fitomegaresults.items()]
            fitomegaresults.sort()
            logger.info('Now writing the full results of the omega-by-site analysis to %s\n' % omegafile)
            with open(omegafile, 'w') as f:
                f.write("# Omega fit to each site after fixing tree and and all other parameters.\n# %s\n# Fits compared to null model of omega = %.3f; P-values NOT corrected for multiple testing.\n#\n# site\tomega\tP\tdLnL\n%s" % (fixsyn_string, fixedomegavalue, '\n'.join(['%d\t%.3f\t%.3g\t%.3f' % (site, omega, p, lnl) for (p, site, omega, lnl) in fitomegaresults])))

    except:
        logger.exception('Terminating %s at %s with ERROR' % (prog, time.asctime()))
        raise
    else:
        logger.info('Successful completion of %s' % prog)
    finally:
        logging.shutdown()



if __name__ == '__main__':
    main() # run the script
