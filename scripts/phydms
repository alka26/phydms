#!python

"""Phylogenetic inference using deep mutational scanning data.

Written by Jesse Bloom."""


import sys
import os
import re
import logging
import random
import tempfile
import time
import math
import multiprocessing
import scipy.stats
import Bio.SeqRecord
import Bio.Phylo
import Bio.Phylo.TreeConstruction
import Bio.Seq
import Bio.Alphabet
import Bio.Alphabet.IUPAC
import Bio.Align
import dms_tools.file_io
import dms_tools.utils
import phydmslib
import phydmslib.file_io
import phydmslib.parsearguments
import phydmslib.pybpp
import phydmslib.diffpref


def FitDiffPrefsForSite(seqnames, iseqs, treefile, imodel, fixedmodelparams, recursion, stringencyscaledprefs, diffprefconc):
    """Fits preferences for a specific site, to be run in multiprocessing pool."""
    start = time.time()
    converged = randinitprefs = False
    ntries = 0
    while (not converged) and ntries < 3:
        tl = phydmslib.pybpp.PyBppTreeLikelihood(seqnames, iseqs, treefile, imodel, infertopology=False, fixedmodelparams=fixedmodelparams, initializemodelparams={}, oldlikelihoodmethod=False, fixbrlen=True, addrateparameter=False, prefsasparams=True, recursion=recursion) 
        initial_ll = tl.LogLikelihood()
        (prefs, convergencestring, converged) = phydmslib.diffpref.OptimizePrefs(tl, stringencyscaledprefs, site=1, concentration=diffprefconc, randinitprefs=randinitprefs)
        tl.SetPreferences(prefs, 1)
        new_ll = tl.LogLikelihood()
        ntries += 1
        randinitprefs = ntries
    return (prefs, new_ll, initial_ll, convergencestring, converged, time.time() - start)


def FitDiffPrefsBySitePool(codons, seqnames, seqs, aaprefs, treefile, fixedmodelparams, stringencyparameter, recursion, diffprefconc, ncpus, logger):
    """Fits a different preference to each site in a multiprocessing pool."""
    pool = multiprocessing.Pool(ncpus)
    diffprefs = {}
    poolresults = {}
    stringencyscaledprefs = {}
    for icodon in codons:
        iseqs = [seq[3 * icodon  - 3 : 3 * icodon] for seq in seqs]
        stringencyscaledprefs[icodon] = dict([(aa, pref**stringencyparameter) for (aa, pref) in aaprefs[icodon].items()])
        prefsum = float(sum(stringencyscaledprefs[icodon].values()))
        stringencyscaledprefs[icodon] = dict([(aa, pref / prefsum) for (aa, pref) in stringencyscaledprefs[icodon].items()])
        imodel = ('ExpCM', {1:stringencyscaledprefs[icodon]})
        poolresults[icodon] = pool.apply_async(FitDiffPrefsForSite, (seqnames, iseqs, treefile, imodel, fixedmodelparams, recursion, stringencyscaledprefs[icodon], diffprefconc))
    completed = dict([(icodon, False) for icodon in codons])
    while not all(completed.values()):
        time.sleep(1)
        for icodon in codons:
            if poolresults[icodon].ready() and not completed[icodon]:
                try:
                    (iprefs, new_ll, initial_ll, convergencestring, converged, itime) = poolresults[icodon].get()
                except:
                    logger.error("Problem fitting diff prefs by site to site %d" % icodon)
                    raise
                idiffprefs = dict([(x, iprefs[x] - stringencyscaledprefs[icodon][x]) for x in iprefs.keys()])
                rmsdiffpref = math.sqrt(sum([x**2 for x in idiffprefs.values()]) / float(len(idiffprefs.values())))
                logger.info("For site %d, fit preferences to natural sequences in %.1f seconds. The increase in log likelihood was %.3g, and the RMS difference in preference is %.3f. Here are the differences in preferences:\n\t%s\n" % (icodon, itime, new_ll - initial_ll, rmsdiffpref, ', '.join(['%s = %.3f' % tup for tup in idiffprefs.items()])))
                if not converged:
                    raise RuntimeError("Diff pref optimization failed to converge for site %d. Here is the optimization message:\n%s" % (icodon, convergencestring))
                assert (new_ll - initial_ll) > -0.01, "Log likelihood of %g with optimized prefs is substantially greater than initial log likelihood of %g for site %d. This indicates a problem with the optimization." % (new_ll, initial_ll, icodon)
                diffprefs[str(icodon)] = idiffprefs
                completed[icodon] = True
    pool.terminate()
    assert len(diffprefs) == len(codons)
    return diffprefs



def FitStringencyForSite(seqnames, iseqs, imodel, fixedmodelparams, fixedstringencyvalue, treefile, recursion):
    """Fits stringency for a specific site, to be run in multiprocessing pool."""
    iresults = {}
    start = time.time()
    for fitstringency in ['fitted', 'fixed']:
        ifixedmodelparams = dict([(param, value) for (param, value) in fixedmodelparams.items()])
        if fitstringency == 'fixed':
            initializemodelparams = {}
            ifixedmodelparams['stringencyparameter'] = fixedstringencyvalue
        else:
            initializemodelparams = {'stringencyparameter':fixedstringencyvalue}
        tl = phydmslib.pybpp.PyBppTreeLikelihood(seqnames, iseqs, treefile, imodel, infertopology=False, fixedmodelparams=ifixedmodelparams, initializemodelparams=initializemodelparams, oldlikelihoodmethod=False, fixbrlen=True, addrateparameter=False, prefsasparams=False, recursion=recursion) 
        tl.OptimizeLikelihood()
        iresults["LnL_%s" % fitstringency] = tl.LogLikelihood()
        if fitstringency == 'fitted':
            iresults['stringency'] = tl.ModelParams(True)['stringencyparameter']
            iresults['stringency_ratio'] = iresults['stringency'] / fixedstringencyvalue
    iresults['dLnL'] = iresults['LnL_fitted'] - iresults['LnL_fixed']
    iresults['P'] = scipy.stats.chi2.sf(2.0 * iresults['dLnL'], df=1)
    return (iresults, time.time() - start)



def FitStringencyBySitePool(codons, seqnames, seqs, aaprefs, fixedmodelparams, fixedstringencyvalue, treefile, recursion, ncpus, logger):
    """Fits a different stringency to each site in a multiprocessing pool."""
    pool = multiprocessing.Pool(ncpus)
    fitstringencyresults = {}
    poolresults = {}
    for icodon in codons:
        iseqs = [seq[3 * icodon  - 3 : 3 * icodon] for seq in seqs]
        imodel = ('ExpCM', {1:aaprefs[icodon]})
        poolresults[icodon] = pool.apply_async(FitStringencyForSite, (seqnames, iseqs, imodel, fixedmodelparams, fixedstringencyvalue, treefile, recursion))
    completed = dict([(icodon, False) for icodon in codons])
    while not all(completed.values()):
        time.sleep(1)
        for icodon in codons:
            if poolresults[icodon].ready() and not completed[icodon]:
                try:
                    (fitstringencyresults[icodon], itime) = poolresults[icodon].get()
                except:
                    logger.error("Problem fitting stringency by site to site %d" % icodon)
                    raise
                completed[icodon] = True
                logger.info('For site %d, fitting a stringency ratio of %.2f (fitted value of %.2f versus gene value of %.2f) increases LnL by %.2f (P-value %.2g). Fitting took %.1f seconds.\n' % (icodon, fitstringencyresults[icodon]['stringency_ratio'], fitstringencyresults[icodon]['stringency'], fixedstringencyvalue, fitstringencyresults[icodon]['dLnL'], fitstringencyresults[icodon]['P'], itime))
    pool.terminate()
    assert len(fitstringencyresults) == len(codons)
    return fitstringencyresults



def FitOmegaForSite(seqnames, iseqs, imodel, fixedmodelparams, fixedomegavalue, treefile, recursion):
    """Fits omega for a specific site, to be run in multiprocessing pool."""
    iresults = {}
    start = time.time()
    for fitomega in ['fitted', 'fixed']:
        ifixedmodelparams = dict([(param, value) for (param, value) in fixedmodelparams.items()])
        if fitomega == 'fixed':
            ifixedmodelparams['omega'] = fixedomegavalue
            initializemodelparams = {}
        else:
            initializemodelparams = {'omega':fixedomegavalue}
        tl = phydmslib.pybpp.PyBppTreeLikelihood(seqnames, iseqs, treefile, imodel, infertopology=False, fixedmodelparams=ifixedmodelparams, initializemodelparams=initializemodelparams, oldlikelihoodmethod=False, fixbrlen=True, addrateparameter=True, prefsasparams=False, recursion=recursion) 
        tl.OptimizeLikelihood()
        iresults["LnL_%s" % fitomega] = tl.LogLikelihood()
        if fitomega == 'fitted':
            iresults['omega'] = tl.ModelParams(True)['omega']
    iresults['dLnL'] = iresults['LnL_fitted'] - iresults['LnL_fixed']
    iresults['P'] = scipy.stats.chi2.sf(2.0 * iresults['dLnL'], df=1)
    return (iresults, time.time() - start)


def FitOmegaBySitePool(codons, seqnames, seqs, aaprefs, model, fixedmodelparams, fixedomegavalue, treefile, recursion, ncpus, logger):
    """Fit a different omega to each site in a multiprocessing pool running *ncpus*."""
    pool = multiprocessing.Pool(ncpus)
    fitomegaresults = {}
    poolresults = {}
    for icodon in codons:
        if model[ : 7] == 'YNGKP_M':
            imodel = 'YNGKP_M0_fitF3X4' # single omega for the site, M0 model
        elif isinstance(model, tuple) and model[0] == 'ExpCM':
            imodel = ('ExpCM', {1:aaprefs[icodon]})
        else:
            raise ValueError("Invalid model")
        iseqs = [seq[3 * icodon  - 3 : 3 * icodon] for seq in seqs]
        poolresults[icodon] = pool.apply_async(FitOmegaForSite, (seqnames, iseqs, imodel, fixedmodelparams, fixedomegavalue, treefile, recursion))
    completed = dict([(icodon, False) for icodon in codons])
    while not all(completed.values()):
        time.sleep(1)
        for icodon in codons:
            if poolresults[icodon].ready() and not completed[icodon]:
                try:
                    (fitomegaresults[icodon], itime) = poolresults[icodon].get()
                except:
                    logger.error("Problem fitting omega by site to site %d" % icodon)
                    raise
                completed[icodon] = True
                logger.info('For site %d, fitting omega to %.2f increases LnL by %.2f relative to fixing omega at %.2f (P-value %.2g). Fitting took %.1f seconds.\n' % (icodon, fitomegaresults[icodon]['omega'], fitomegaresults[icodon]['dLnL'], fixedomegavalue, fitomegaresults[icodon]['P'], itime))
    pool.terminate()
    assert len(fitomegaresults) == len(codons)
    return fitomegaresults



def main():
    """Main body of script."""

    # some regular expressions used later
    yngkp_match = re.compile('^YNGKP_M(?P<modelvariant>[0,3,7,8])$')

    # Parse command line arguments
    parser = phydmslib.parsearguments.PhyDMSParser()
    args = vars(parser.parse_args())
    prog = parser.prog

    # create output directory if needed
    outdir = os.path.dirname(args['outprefix'])
    if outdir:
        if not os.path.isdir(outdir):
            if os.path.isfile(outdir):
                os.remove(outdir)
            os.mkdir(outdir)

    # name files, remove if they already exist
    modelparamsfile = '%s_modelparams.txt' % args['outprefix']
    loglikelihoodfile = '%s_loglikelihood.txt' % args['outprefix']
    treefile = "%s_tree.newick" % args['outprefix']
    omegafile = '%s_omegabysite.txt' % args['outprefix']
    stringencyfile = '%s_stringencybysite.txt' % args['outprefix']
    diffprefsfile = '%s_diffprefsbysite.txt' % args['outprefix']
    logfile = "%s.log" % args['outprefix']
    if args['no_optimize']:
        to_remove = [omegafile, stringencyfile, diffprefsfile, logfile]
        assert args['tree'] == treefile, "When using --no_optimize, you must set 'tree' to the name of the file that would be expected to be created for this 'outprefix', which is %s in this case" % treefile
    else:
        to_remove = [modelparamsfile, loglikelihoodfile, treefile, omegafile, stringencyfile, diffprefsfile, logfile]
    for f in to_remove:
        if os.path.isfile(f):
            os.remove(f)

    # Set up to log everything to logfile.
    logging.shutdown()
    versionstring = phydmslib.file_io.Versions() 
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s', level=logging.INFO)
    logger = logging.getLogger(prog)
    logfile_handler = logging.FileHandler(logfile)
    logger.addHandler(logfile_handler)
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    logfile_handler.setFormatter(formatter)

    # begin execution
    try:

        # print some basic information
        logger.info('Beginning execution of %s in directory %s\n' % (prog, os.getcwd()))
        logger.info('Progress is being logged to %s\n' % logfile)
        logger.info("%s\n" % versionstring)
        logger.info('Parsed the following command-line arguments:\n%s\n' % '\n'.join(['\t%s = %s' % tup for tup in args.iteritems()]))

        logger.info('Seeding random number generator with %d\n' % args['seed'])
        random.seed(args['seed'])

        # some checks on arguments
        if args['tree'] == 'random' and not args['infertopology']:
            raise ValueError("It does not make sense to use ``tree`` of *random* without also using ``--infertopology``")
        if args['fixbrlen'] and args['infertopology']:
            raise ValueError("It does not make sense to ``--fixbrlen`` with ``--infertopology``")
        if args['addrateparameter'] and not args['fixbrlen']:
            raise ValueError("It does not make sense to use --addrateparameter without also using --fixbrlen, as otherwise branch lengths are already scaled by rate.")

        # read alignment
        logger.info('Reading alignment from %s' % args['alignment'])
        alignment = phydmslib.file_io.ReadCodonAlignment(args['alignment'], checknewickvalid=True)
        seqnames = set([head for (head, seq) in alignment])
        logger.info('Read %d aligned codon sequences from %s. Each sequences consists of %d codons.\n' % (len(alignment), args['alignment'], len(alignment[0][1]) // 3))

        # process the substitution model
        if isinstance(args['model'], str) and yngkp_match.search(args['model']):
            for argname in ['stringencybysite', 'diffprefsbysite', 'randprefs', 'avgprefs']:
                if args[argname]:
                    raise ValueError("You can use '--%s' only with an ExpCM model" % argname)
            modelvariant = yngkp_match.search(args['model']).group('modelvariant')
            if args['infertopology'] and int(modelvariant) != 0:
                raise ValueError("You cannot use '--infertopology' with model %s" % args['model'])
            logger.info('The codon substitution model with be the M%s version of YNGKP (Yang, Nielsen, Goldman, and Pederson. Genetics. 155:431-449).' % modelvariant)
            if args['fitF3X4']:
                logger.info('The codon equilibrium frequencies will be set by F3X4, optimizing the nine nucleotide frequencies by maximum likelihood.\n')
                model = args['model'] + '_fitF3X4'
            else:
                logger.info('The codon equilibrium frequencies will be set by F3X4, estimating the nine nucleotide frequencies empirically from the alignment frequencies.\n')
                model = args['model'] + '_empF3X4'
        elif isinstance(args['model'], tuple) and len(args['model']) == 2 and args['model'][0] == 'ExpCM':
            assert not args['infertopology'], "You cannot use '--infertopology' with ExpCM"
            assert not args['fitF3X4'], "You cannot use '--fitF3X4' with ExpCM"
            prefsfilename = args['model'][1]
            logger.info('The codon substitution model will be experimentally informed model by the site-specific amino-acid preferences in %s' % prefsfilename)
            (sites, wts, pi_means, pi_95credint, h) = dms_tools.file_io.ReadPreferences(prefsfilename)
            if len(sites) != len(alignment[0][1]) // 3:
                raise ValueError("The number of amino-acid preferences in %s does not match the number of codon sites in the alignment" % prefsfilename)
            if not all([r.isdigit() for r in sites]):
                raise ValueError("All sites in preferences file must be integers")
            sites = [int(r) for r in sites]
            assert len(set(sites)) == len(sites), "There are non-unique sites in the preferences file"
            if not (min(sites) == 1 and max(sites) - min(sites) == len(sites) - 1):
                raise ValueError("Sites in preferences file must start at 1 and be consecutive")
            pi_means = dms_tools.utils.RemoveStopFromPreferences(pi_means)
            aas = pi_means['1'].keys()
            if set(aas) != set(Bio.Alphabet.IUPAC.IUPACProtein.letters):
                raise ValueError("Preferences are not specified for the 20 amino acids")
            assert all([set(aas) == set(ipi.keys()) for ipi in pi_means.values()]), "Not same amino acid keys for all sites"
            aaprefs = dict([(int(r), rprefs) for (r, rprefs) in pi_means.items()])
            logger.info('Successfully read site-specific amino-acid preferences for all %d sites.\n' % len(aaprefs))
            if args['randprefs']:
                assert not args['avgprefs'], "Cannot use both '--randprefs' and '--avgprefs'"

                logger.info("Now randomizing these amino-acid preferences among sites.\n")
                rs = [r for r in aaprefs.keys()]
                aaprefs = [rprefs for rprefs in aaprefs.values()]
                random.shuffle(rs)
                aaprefs = dict(zip(rs, aaprefs))
            elif args['avgprefs']:
                assert not args['randprefs'], "Cannot use both '--randprefs' and '--avgprefs'"
                logger.info("Now averaging these amino-acid preferences across sites.\n")
                avg_prefs = dict([(aa, 0.0) for aa in aas])
                for rprefs in aaprefs.values():
                    for aa in aas:
                        avg_prefs[aa] += rprefs[aa]
                for aa in aas:
                    avg_prefs[aa] /= float(len(aaprefs))
                for r in aaprefs.keys():
                    aaprefs[r] = avg_prefs
            model = ('ExpCM', aaprefs)
        else:
            raise ValueError("Invalid model of %s" % args['model'])

        # read or create the tree
        if args['tree'] == 'random':
            assert not args['no_optimize'], "Cannot use --no_optimize with tree of 'random'"
            logger.info("Creating a random initial tree.")
            tree = Bio.Phylo.BaseTree.Tree.randomized(seqnames, branch_length=1.0)
        elif args['tree'] == 'nj':
            assert not args['no_optimize'], "Cannot use --no_optimize with tree of 'nj'"
            logger.info('Creating an initial tree from nucleotide sequences by neighbor joining using a crude identity scoring matrix...')
            msa = Bio.Align.MultipleSeqAlignment([Bio.SeqRecord.SeqRecord(Bio.Seq.Seq(seq, Bio.Alphabet.generic_dna), id=head) for (head, seq) in alignment])
            calculator = Bio.Phylo.TreeConstruction.DistanceCalculator('identity')
            tree = Bio.Phylo.TreeConstruction.DistanceTreeConstructor(calculator, 'nj').build_tree(msa)
            logger.info("Finished creating a crude neighbor-joining initial tree.")
        else:
            logger.info("Reading tree from %s" % args['tree'])
            tree = Bio.Phylo.read(args['tree'], 'newick')
        tipnames = set([clade.name for clade in tree.get_terminals()])
        if tipnames != seqnames:
            raise ValueError("The sequence names in alignment do not match those in tree.\nSequences in alignment but NOT in tree:\n\t%s\nSequences in tree but NOT in alignment:\n\t%s" % ('\n\t'.join(seqnames - tipnames), '\n\t'.join(tipnames - seqnames)))
        logger.info('This tree has %d tips nodes, matching the sequences in alignment.' % len([clade.name for clade in tree.get_terminals()]))
        nadjustedbrlen = 0
        for node in tree.get_terminals() + tree.get_nonterminals():
            if node != tree.root and node.branch_length < args['minbrlen']:
                node.branch_length = args['minbrlen']
                nadjustedbrlen += 1
        if nadjustedbrlen:
            logger.info('Ensured that all branch lengths are >= minimum of %g by adjusting %d lengths up to this value.\n' % (args['minbrlen'], nadjustedbrlen))
        else:
            logger.info('Confirmed that all branch lengths are >= minimum of %g.\n' % args['minbrlen'])
        newicktree = tree.format('newick').strip()
        # remove internal node names because they cause problem in parsing tree later
        for node in tree.get_nonterminals():
            if node.name: # root node won't have name
                toremove = ')' + node.name + ':'
                assert toremove in newicktree, "Cannot find internal node %s in form %s in tree:\n%s" % (node.name, toremove, newicktree)
                newicktree = newicktree.replace(toremove, '):')
        seqnames = [head for (head, seq) in alignment]
        seqs = [seq for (head, seq) in alignment]

        # now optimize tree 
        if args['no_optimize']:
            require_files = [modelparamsfile, loglikelihoodfile, treefile]
            logger.info("Because --no_optimize is being used, the tree and model parameters will not be optimized. Instead using the existing values from a previous optimization in the following files: %s\n" % ', '.join(require_files))
            if not all([os.path.isfile(f) for f in require_files]):
                raise ValueError("Cannot use --no_optimize' because cannot find all of the existing optimization files: %s" % ', '.join(require_files))
            with open(loglikelihoodfile) as f:
                old_ll = float(f.readlines()[0].split('=')[1])
            with open(modelparamsfile) as f:
                modelparams = dict([(line.split('=')[0].strip(), float(line.split('=')[1])) for line in f])
            allmodelparams = modelparams
            tl = phydmslib.pybpp.PyBppTreeLikelihood(seqnames, seqs, treefile, model, args['infertopology'], fixedmodelparams=modelparams, initializemodelparams={}, oldlikelihoodmethod=False, fixbrlen=args['fixbrlen'], addrateparameter=args['addrateparameter'], prefsasparams=False, recursion=args['recursion'])
            assert not tl.ModelParams(True), "There are unspecified model parameters to be optimized for --no_optimize: %s" % str(tl.ModelParams(True))
            if set(tl.ModelParams(False).keys()) != set(modelparams.keys()):
                raise ValueError("The existing model params file %s does not have all of the expected parameters for this substitution model, so cannot use --no_optimize. Either the existing model parameters were created with a different model, or you used a YNGKP model without --fitF3X4 (this is currently incompatible with --no_optimize).")
            if abs(tl.LogLikelihood() - old_ll) > 0.5:
                raise ValueError("Incompatibility between old log likelihood %g and new one of %g" % (old_ll, tl.LogLikelihood()))
        else:
            try:
                (fd, temptreefile) = tempfile.mkstemp() # create temporary file to write tree for passing
                with os.fdopen(fd, 'w') as f:
                    f.write(newicktree)
                if isinstance(model, str) and 'YNGKP' in model:
                    oldlikelihoodmethod = True
                else:
                    oldlikelihoodmethod = False
                logger.info('Creating Bio++ object to optimize likelihood...')
                tl = phydmslib.pybpp.PyBppTreeLikelihood(seqnames, seqs, temptreefile, model, args['infertopology'], fixedmodelparams={}, initializemodelparams={}, oldlikelihoodmethod=oldlikelihoodmethod, fixbrlen=args['fixbrlen'], addrateparameter=args['addrateparameter'], prefsasparams=False, recursion=args['recursion'])
            finally:
                if os.path.isfile(temptreefile):
                    os.remove(temptreefile)
            logger.info('Created Bio++ object to optimize likelihood for the %d codon sites of the %d sequences.\n' % (tl.NSites(), tl.NSeqs()))
            logger.info('The initial log likelihood is %g; now optimizing by maximum likelihood...' % tl.LogLikelihood())
            tl.OptimizeLikelihood()
            logger.info('Completed optimizing by maximum likelihood.')
            logger.info("Here is the optimized log likelihood (also being written to %s): %g." % (loglikelihoodfile, tl.LogLikelihood()))
            with open(loglikelihoodfile, 'w') as f:
                f.write('log likelihood = %g' % tl.LogLikelihood())
            modelparams = tl.ModelParams(True)
            modelparamstextlist = ['%s = %.6f' % tup for tup in modelparams.items()]
            modelparamstextlist.sort()
            logger.info("Here are the optimized model parameters (also being written to %s):\n\t%s" % (modelparamsfile, '\n\t'.join(modelparamstextlist)))
            with open(modelparamsfile, 'w') as f:
                f.write('\n'.join(modelparamstextlist))
            logger.info("Here is the optimized tree (also being written to %s):\n%s" % (treefile, tl.NewickTree()))
            with open(treefile, 'w') as f:
                f.write(tl.NewickTree())
            allmodelparams = tl.ModelParams(False)
            del tl

        # get number of cpus for multiprocessing
        if args['ncpus'] == -1:
            try:
                args['ncpus'] = multiprocessing.cpu_count()
            except:
                raise RuntimeError("Problem trying to determine number of available CPUs. Please manually specify the number of desired CPUs with '--ncpus' and try again.")
        logger.info("Using %d CPUs for the remaining computations.\n" % args['ncpus'])
        assert args['ncpus'] >= 1, "Failed to specify a number of CPUs that exceeds one: %d." % args['ncpus']

        # list of all codons
        codons = [icodon for icodon in range(1, len(seqs[0]) // 3 + 1)]

        # optimize a different omega for each site
        if args['omegabysite']:
            fixedomegavalue = 1.0 # null model fixes omega to this value
            excludeparams = ['omega', 'p', 'q', 'omegas', 'p0', 'delta1', 'delta2', 'omega0', 'theta1', 'theta2'] # parameters related to omega, do not fix
            fixedmodelparams = {}
            for (param, value) in allmodelparams.items():
                for excludeparam in excludeparams:
                    if excludeparam == param:
                        break
                else:
                    fixedmodelparams[param] = value
            logger.info('Now optimizing a different omega for each site while keeping branch lengths and other model parameters fixed (but adding a rate parameter that effectively scales the branch lengths).')
            logger.info('The tree and branch lengths will be fixed to the values in %s' % treefile)
            logger.info('The model parameters (other than omega and the rate) will be to fixed to the following:\n\t%s\n' % '\n\t'.join(['%s = %g' % tup for tup in fixedmodelparams.items()]))
            if isinstance(model, str) and 'YNGKP' in model:
                aaprefs = {}
            fitomegaresults = FitOmegaBySitePool(codons, seqnames, seqs, aaprefs, model, fixedmodelparams, fixedomegavalue, treefile, args['recursion'], args['ncpus'], logger)
            fitomegaresults = [(d['P'], site, d['omega'], d['dLnL']) for (site, d) in fitomegaresults.items()]
            fitomegaresults.sort()
            logger.info('Now writing the full results of the omega-by-site analysis to %s\n' % omegafile)
            with open(omegafile, 'w') as f:
                f.write("# Omega fit to each site after fixing tree and and all other parameters.\n# Fits compared to null model of omega = %.3f; P-values NOT corrected for multiple testing.\n#\n# site\tomega\tP\tdLnL\n%s" % (fixedomegavalue, '\n'.join(['%d\t%.3f\t%.3g\t%.3f' % (site, omega, p, lnl) for (p, site, omega, lnl) in fitomegaresults])))

        # optimize a different stringency parameter for each site
        if args['stringencybysite']:
            assert isinstance(model, tuple) and model[0] == 'ExpCM', "stringencybysite only allowed for ExpCM"
            fixedstringencyvalue = modelparams['stringencyparameter'] # null model fixes stringency to this value
            fixedmodelparams = dict([(param, value) for (param, value) in allmodelparams.items() if param != 'stringencyparameter'])
            logger.info('Now optimizing a different stringency parameter for each site while keeping branch lengths and other model parameters fixed. This will be compared to a null model where the stringency parameter is equal to the overall gene value of %.2f.' % fixedstringencyvalue)
            logger.info('The tree and branch lengths will be fixed to the values in %s' % treefile)
            logger.info('The model parameters (other than the stringency parameter) will be to fixed to the following:\n\t%s\n' % '\n\t'.join(['%s = %g' % tup for tup in fixedmodelparams.items()]))
            fitstringencyresults = FitStringencyBySitePool(codons, seqnames, seqs, aaprefs, fixedmodelparams, fixedstringencyvalue, treefile, args['recursion'], args['ncpus'], logger)
            fitstringencyresults = [(d['P'], site, d['stringency_ratio'], d['dLnL']) for (site, d) in fitstringencyresults.items()]
            fitstringencyresults.sort()
            logger.info('Now writing the full results of the stringency-by-site analysis to %s\n' % stringencyfile)
            with open(stringencyfile, 'w') as f:
                f.write("# Stringency fit to each site after fixing tree and and all other parameters.\n# Fits compared to null model of stringency = %.3f (the overall gene value).\n# P-values NOT corrected for multiple testing.\n# The stringency ratio is the ratio of the fitted value to the null (overall gene value).\n#\n# site\tstringency_ratio\tP\tdLnL\n%s" % (fixedstringencyvalue, '\n'.join(['%d\t%.3f\t%.3g\t%.3f' % (site, stringencyratio, p, lnl) for (p, site, stringencyratio, lnl) in fitstringencyresults])))

        # optimize differential preferences for each site
        if args['diffprefsbysite']:
            assert isinstance(model, tuple) and model[0] == 'ExpCM', "diffprefsbysite only allowed for ExpCM"
            fixedmodelparams = dict([(param, value) for (param, value) in allmodelparams.items() if param != 'stringencyparameter'])
            fixedmodelparams['stringencyparameter'] = 1.0
            logger.info('Now estimating the difference between the preferences specified in %s and those that best describe the natural evolution. We optimize the preferences after regularizing them using a Dirichlet (concentration %.2f) centered on the preferences provided in the file. The preferences in the file are first rescaled by the stringency parameter value of %.2f previously optimized for the entire sequence / tree, and the difference in preferences are relative to these rescaled preferences. After this rescaling, the stringency parameter is set to one. All other model parameters are fixed to their maximum likelihood values for the entire sequence / tree.' % (prefsfilename, args['diffprefconc'], modelparams['stringencyparameter']))
            logger.info('The tree and branch lengths will be fixed to the values in %s' % treefile)
            logger.info('The model parameters will be to fixed to the following:\n\t%s\n' % '\n\t'.join(['%s = %g' % tup for tup in fixedmodelparams.items()]))
            sites = [str(icodon) for icodon in codons]
            wts = dict([(isite, '?') for isite in sites])
            diffprefs = FitDiffPrefsBySitePool(codons, seqnames, seqs, aaprefs, treefile, fixedmodelparams, modelparams['stringencyparameter'], args['recursion'], args['diffprefconc'], args['ncpus'], logger)
            logger.info('Writing the differences in preferences to %s\n' % diffprefsfile)
            pr_deltapi = dict([(isite, None) for isite in sites]) # empty, as we have no data here
            dms_tools.file_io.WriteDiffPrefs(diffprefsfile, sites, wts, diffprefs, pr_deltapi, pr_deltapi)

    except:
        logger.exception('Terminating %s at %s with ERROR' % (prog, time.asctime()))    
        raise
    else:
        logger.info('Successful completion of %s' % prog)
    finally:
        logging.shutdown()



if __name__ == '__main__':
    main() # run the script
